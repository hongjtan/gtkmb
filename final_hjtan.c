/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\
* TITLE: GTK Media Box							      *
* AUTHOR: Hong Tan							      *
* DATE: April 5, 2010							      *
* MODIFIED: May 20, 2010						      *
* VERSION: 0.0.3							      *
*									      *
* This program is designed to play media files using an autoplugger method,   *
* which chooses the best decoder given a stream. Has the functions of a	      *
* standard media player and uses gstreamer codecs. Functions better when using*
* the X Window System.							      *
*									      *
*									      *
* INSTALL FROM PACKAGE MANAGER:						      *
*	- GTK 2.18+ and all required libraries.				      *
*	- gstreamer development libraries, plugins, codecs for whichever      *
*	  files you want to play, etc. [base plugin development libraries     *
*	  need to be installed as well.]				      *
*	  (gstreamer0.10, libgstreamer-plugins-base0.10-0-dev)		      *
*	- Taglib C Bindings development libraries.			      *
*	  (libtagc0-dev)						      *
*	- GnomeVFS 2.0 development libraries.				      *
*	  (libgnomevfs2-dev)						      *
*	- *UPDATE* libtotem_plparser-dev-2.30 now supported.		      *
*	- libtotem-plparser-dev-2.28 required for UNIX systems. In order to   *
*	  compile on 2.28, uncomment 2.28 code in save_pl_button_clicked and  *
*	  comment out 2.30 code and vice versa for changing back.	      *
*	- Of course, all corresponding runtime libraries need to be installed *
*	  as well.							      *
*									      *
* TO COMPILE: gcc -Wall -g -o final_hjtan final_hjtan.c \		      *
* `pkg-config --cflags --libs gtk+-2.0 gstreamer-interfaces-0.10 \	      *
*  gstreamer-video-0.10 taglib_c totem-plparser gnome-vfs-2.0`		      *
*									      *
* TO DO: (I = Incomplete, C = Complete, P = Partially Fixed)		      *
*	C [HIGH] Put video window in a window that I create myself to catch   *
*		 button presses. [Decided to compromise, environments not     *
*		 using the X Window System will get an automatic window	      *
*		 window generated by gstreamer, not catching button presses,  *
*		 therefore, the application will run better on environments   *
*		 which do use it.]					      *
*	C [HIGH] Add to playlist is currently opening files instead of adding *
*	         to playlist for testing purposes.			      *
*	C [HIGH] Add a playlist using tree view that switches to the next song*
*		 as soon as playback for one is done.			      *
*	C [HIGH] strrchr in add_button_clicked is crashing in Windows but is  *
*		 fine on Linux.						      *
*	C [MEDIUM] Seek bar.						      *
*	C [MEDIUM] Volume bar.						      *
*	C [MEDIUM] Catch button presses in the video screen.		      *
*	C [LOW] Monitoring the program in process manager shows a minor memory*
*		Leak if you repeatedly grab file info.			      *
*	C [LOW] Constrain proportions of the video when in full screen, so    *
*		image doesn't look stretched.				      *
*		[Fixed by putting my own video sink inside the playbin and    *
*		setting the force-aspect-ratio property.]		      *
*	C [LOW] Need to clear the drawing area after videos are stopped or    *
*		window size is changed.					      *
*									      *
*	I [HIGH] Split the code into separate files.			      *
*	I [MEDIUM] Shuffle at the moment is with replacement and loops.	      *
*	I [LOW] Filter so you can only open supported file formats.	      *
*	P [LOW] Add loop and shuffle buttons that go back to the first element*
*		of the tree view after it is done playing or generate a random*
*		track number to play, respectively.			      *
*	I [LOW] Re-open the last playlist that was open before the program    *
*		last closed.						      *
*	I [LOW] Setting a pause icon in the playlist did not work correctly,  *
*		and has therefore been set aside.			      *
*	P [LOW] There are some iterator problems, but I can't reproduce them. *
*		[Most of these have been fixed, I haven't been able to produce*
*		any new iterator warnings or errors.]			      *
*									      *
*	[NOTE] Sometimes upon first playing a file will lag. Not sure if it's *
*	       a gstreamer problem or something in the code.		      *
*	       [Seems to happen on slower systems, such as a virtual system.] *
*	[NOTE] Taglib only tags select audio files, and no video files.	      *
*	[NOTE] Code is pretty unorganized and messy since I didn't do any     *
*	       cleanup or split files yet.				      *
*									      *
\* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\
* Update April 16, 2013 - New compile command.                                *
* gcc -g -o final_hjtan final_hjtan.c `pkg-config --cflags --libs \           *
* gtk+-2.0 gstreamer-0.10 gstreamer-interfaces-0.10 gstreamer-video-0.10 \    *
* gnome-vfs-2.0 totem-plparser taglib` -ltag_c                                *
\* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

#include <stdio.h>
#include <string.h>
#include <gst/gst.h>
#include <gtk/gtk.h>
#include <glib.h>
#include <glib/gprintf.h>
#include <taglib/tag_c.h>

#ifdef unix
	#include <totem-pl-parser.h> 
	#include <libgnomevfs/gnome-vfs.h>
#endif

#ifdef GDK_WINDOWING_X11
	#include <gdk/gdkx.h>
	#include <gdk/gdkkeysyms.h>
	#include <gst/interfaces/xoverlay.h>
	#include <gst/video/video.h>
#endif

#define INITIAL_VALUE 0
#define MIN_VALUE 0
#define MAX_VALUE 100
#define MAX_CHARS 256
#define WIN_WIDTH 360
#define WIN_HEIGHT 110

// Global variables.
static gboolean loop = FALSE, shuffle = FALSE;
static GtkTreeIter selected;	// Iterators which point to the track
				// that is currently selected. Needed for
				// setting "playing" pixbuf.
static GtkTreePath *playing;	// Points to the currently playing track.
static GtkTreeIter editing;	// Points to the track being edited.
static gint num_tracks = 0;	// Total number of tracks in the playlist.

// Enumeration of playlist tree view columns.
enum
{
	COL_PLAYING = 0,
	COL_TRACK_NAME,
	COL_LENGTH,
	COL_URI,
	COL_FILENAME,
	NUM_COLS
};

// Tag information.
typedef struct
{
	gchar *title;
	gchar *artist;
	gchar *album;
	gint year;
	gchar *comment;
	gint track;
	gchar *genre;
	gint bitrate;
	gint samplerate;
	gint channels;
	gchar length[8];
} tag_info;

// Function declarations.
static void back_button_clicked (GtkWidget *widget, gpointer data);
static void play_button_clicked (GtkWidget *widget, gpointer data);
static void pause_button_clicked (GtkWidget *widget, gpointer data);
static void stop_button_clicked (GtkWidget *widget, gpointer data);
static void next_button_clicked (GtkWidget *widget, gpointer data);
static void add_button_clicked (GtkWidget *widget, gpointer data);
static void remove_button_clicked (GtkWidget *widget, gpointer data);
static void open_pl_button_clicked (GtkWidget *widget, gpointer data);
static void loop_button_clicked (GtkWidget *widget, gpointer data);
static void shuffle_button_clicked (GtkWidget *widget, gpointer data);
static gboolean pl_delete (GtkWidget *widget, gpointer data);
void new_pl_button_clicked (GtkWidget *widget, gpointer data);
#ifdef unix
TotemPlParserResult parse_pl (gchar *uri, GtkListStore *pl_entries);
static void parsed_entry (TotemPlParser *parser,
			  gchar *uri,
			  GHashTable *metadata,
			  gchar data);
static void load_pl_button_clicked (GtkWidget *widget, gpointer data);
static void save_pl_button_clicked (GtkWidget *widget, gpointer data);
void save_parser (GtkTreeModel *model, GtkTreeIter *iter, gchar **uri,
		  gchar **title, gboolean *custom_title, gpointer data);
#endif
static gboolean bus_message (GstBus *bus, GstMessage *message, gpointer data);
void error_dialog (GtkWidget *parent, gchar *error_text);
static GtkWidget *create_treeview (GtkListStore *list);
void add_data_at_end (GtkListStore *list,
		      tag_info tag,
		      gchar* uri,
		      gchar* filename);
void reset_data (GtkWidget *treeview,
		 GtkListStore *list,
		 gchar *artist,
		 gchar *title);
void clear_pixbuf (GtkListStore *list, GtkTreeView *treeview);
static gboolean parse_tag (gchar *filename, tag_info *track_tag);
void double_click_row (GtkTreeView *treeview, GtkTreePath *path,
                       GtkTreeViewColumn *col, gpointer data);
void focus_change (GtkTreeView *treeview, gpointer data);
static gboolean track_bar_callback (GstElement *pipeline);
static void volume_changed (GtkWidget *widget, gpointer data);
static void seek_changed (GtkWidget *widget, gpointer data);
static void on_row_delete (GtkTreeModel *model,
			   GtkTreePath *path,
			   gpointer data);
static void quit_program (GtkWidget *widget, gpointer data);

gboolean on_button_press (GtkWidget *treeview,
			  GdkEventButton *event,
			  gpointer data);
static void playlist_popup (GtkWidget *treeview,
			    GdkEventButton *event,
			    gpointer data);
	static void menu_play (GtkWidget *widget, gpointer data);
	static void menu_remove (GtkWidget *widget, gpointer data);
	static void menu_tag (GtkWidget *widget, gpointer data);
		static void save_button_clicked (GtkWidget *widget,
						 gpointer data);
		static void cancel_button_clicked (GtkWidget *widget,
						   gpointer data);

// Code specific to environments using the X Window System.
#ifdef GDK_WINDOWING_X11
static gulong video_window_xid = 0;
static gint window_state = 1;

static GstBusSyncReply bus_sync (GstBus *bus,
				 GstMessage *message,
				 gpointer data);
static void video_realized (GtkWidget *widget, gpointer data);
gboolean catch_video_button (GtkWidget *widget,
			     GdkEventButton *event,
			     gpointer data);
gboolean catch_window_key (GtkWidget *window,
			      GdkEventKey *event,
			      gpointer data);
gboolean window_fullscreen (GtkWidget *widget,
			    GdkEventWindowState *event,
			    gpointer data);
gboolean window_motion (GtkWidget *widget,
			    GdkEventMotion *event,
			    gpointer data);
#endif

int main (int argc, char *argv[])
{	
	GtkWidget *window,	// The main window of the program.
		  *pl_window,	// The window for the playlist.
		  *vbox,	// The vertical box which holds hbox.
		  *hbox_seek,	// Holds the seek bar and time display.
		  *hbox_buttons,// Holds the buttons of the player.
		  *vbox_pl,	// Vertical box for the playlist.
		  *hbox_pl;	// Holds the buttons for the playlist.
	GtkWidget *back, *play, *pause, *stop, *next, *add, *remove, *open_pl,
		  *new_pl, *load_pl, *save_pl, *separate, *loop, *shuffle;
	GtkWidget *back_icon,	// Icons representing each of the buttons on
		  *play_icon,	// player.
		  *pause_icon,
		  *stop_icon,
		  *next_icon,
		  *add_icon,
		  *remove_icon,
		  *open_pl_icon,
		  *new_pl_icon,
		  *load_pl_icon,
		  *save_pl_icon,
		  *loop_icon,
		  *shuffle_icon;
	GtkWidget *scroll_pl;	// Scroll window for the playlist.
	GtkWidget *playlist;	// Used for the playlist.
	GtkWidget *volume_bar,	// Volume scale.
		  *seek_bar,	// Seek scale.
		  *seek_label,	// Seek time display.
		  *track_label;	// Track artist and title display.
	GtkObject *seek_adjust,	// Holds adjustments for the seek and volume
		  *vol_adjust;	// control.
	GtkListStore *pl_entries;	// Used to hold the playlist entries.
	GdkPixbuf *window_icon,	// The window's icon.
		  *playing_icon,// The play indicator icon.
		  *paused_icon;	// The paused indicator icon.
	GtkWidget *volume_icon; // Volume icon.
	GstElement *bin,	// A playbin to decode, demux, etc. audio/video
		   *video_sink;	// files and a video sink to set properties.
	GstBus *bus;		// A bus that grabs messages from the playbin
				// pipeline.
	gdouble volume;		// Holds the starting volume of the playbin.
	guint timeout_id;	// Holds the ID for the timeout function. 
	GtkTreeSelection *selection;

	gst_init (&argc, &argv);
	gtk_init (&argc, &argv);

	#ifdef GDK_WINDOWING_X11
	// Code adapted from gstreamer documentation.
	GtkWidget *video;

	video = gtk_drawing_area_new ();
	gtk_widget_set_events (video, GDK_BUTTON_PRESS_MASK |
				      GDK_KEY_PRESS_MASK);
	g_signal_connect (video, "realize",
			  G_CALLBACK (video_realized), NULL);
	g_signal_connect (video, "button-press-event",
			  G_CALLBACK (catch_video_button), NULL);
	#endif

	// Create labels to display time and track artist/title.
	seek_label = gtk_label_new ("--:--:-- / --:--:--");
	gtk_label_set_single_line_mode (GTK_LABEL (seek_label), TRUE);
	track_label = gtk_label_new ("No Track Selected");
	gtk_label_set_single_line_mode (GTK_LABEL (track_label), TRUE);
	gtk_misc_set_alignment (GTK_MISC (track_label), 0, 0.5);
	gtk_misc_set_padding (GTK_MISC (track_label), 5, 5);

	// Create the window and set its properties.
	window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
	window_icon = gdk_pixbuf_new_from_file ("./img/icon.png", NULL);
	gtk_widget_set_size_request (window, WIN_WIDTH, WIN_HEIGHT);
	gtk_window_set_title (GTK_WINDOW (window), "GTK Media Box");
	gtk_window_set_resizable (GTK_WINDOW (window), TRUE);
	gtk_window_set_icon (GTK_WINDOW (window), window_icon);

	pl_window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
	gtk_window_set_title (GTK_WINDOW (pl_window), "Playlist");
	gtk_widget_set_size_request (pl_window, 410, 200);
	gtk_window_set_resizable (GTK_WINDOW (pl_window), TRUE);
	gtk_window_set_icon (GTK_WINDOW (pl_window), window_icon);
	gtk_window_set_destroy_with_parent (GTK_WINDOW (pl_window), TRUE);
	gtk_window_set_position (GTK_WINDOW (pl_window), GTK_WIN_POS_CENTER);

	// Create the frames on the player.
	vbox = gtk_vbox_new (FALSE, 5);
	hbox_seek = gtk_hbox_new (FALSE, 5);
	hbox_buttons = gtk_hbox_new (FALSE, 5);
	vbox_pl = gtk_vbox_new (FALSE, 5);
	hbox_pl = gtk_hbox_new (FALSE, 5);
	
	// Create the playlist treeview and list.
	scroll_pl = gtk_scrolled_window_new (NULL, NULL);
	gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (scroll_pl),
					GTK_POLICY_NEVER,
					GTK_POLICY_AUTOMATIC);

	pl_entries = gtk_list_store_new (NUM_COLS,
					 GDK_TYPE_PIXBUF,
					 G_TYPE_STRING,
					 G_TYPE_STRING,
					 G_TYPE_STRING,
					 G_TYPE_STRING);

	playlist = create_treeview (pl_entries);
	gtk_tree_view_set_rules_hint (GTK_TREE_VIEW (playlist), TRUE);
	gtk_container_add (GTK_CONTAINER (scroll_pl), playlist);
	selection = gtk_tree_view_get_selection (GTK_TREE_VIEW (playlist));
	gtk_tree_selection_set_mode (selection, GTK_SELECTION_BROWSE);

	playing_icon = gdk_pixbuf_new_from_file
				("./img/playing.png", NULL);
	paused_icon = gdk_pixbuf_new_from_file
				("./img/paused.png", NULL);
	volume_icon = gtk_image_new_from_file
				("./img/volume.png");

	// Create the buttons on the player.
	back = gtk_button_new ();
	back_icon = gtk_image_new_from_file ("./img/back.png");
	gtk_button_set_image (GTK_BUTTON (back), back_icon);
	gtk_widget_set_tooltip_text (back, "Previous Track");
	
	play = gtk_button_new ();
	play_icon = gtk_image_new_from_file ("./img/play.png");
	gtk_button_set_image (GTK_BUTTON (play), play_icon);
	gtk_widget_set_tooltip_text (play, "Play");

	pause = gtk_button_new ();
	pause_icon = gtk_image_new_from_file ("./img/pause.png");
	gtk_button_set_image (GTK_BUTTON (pause), pause_icon);
	gtk_widget_set_tooltip_text (pause, "Pause");

	stop = gtk_button_new ();
	stop_icon = gtk_image_new_from_file ("./img/stop.png");
	gtk_button_set_image (GTK_BUTTON (stop), stop_icon);
	gtk_widget_set_tooltip_text (stop, "Stop");

	next = gtk_button_new ();
	next_icon = gtk_image_new_from_file ("./img/next.png");
	gtk_button_set_image (GTK_BUTTON (next), next_icon);
	gtk_widget_set_tooltip_text (next, "Next Track");

	add = gtk_button_new ();
	add_icon = gtk_image_new_from_file ("./img/add.png");
	gtk_button_set_image (GTK_BUTTON (add), add_icon);
	gtk_widget_set_tooltip_text (add, "Add to Playlist...");

	remove = gtk_button_new ();
	remove_icon = gtk_image_new_from_file ("./img/remove.png");
	gtk_button_set_image (GTK_BUTTON (remove), remove_icon);
	gtk_widget_set_tooltip_text (remove, "Remove from Playlist");

	open_pl = gtk_toggle_button_new ();
	open_pl_icon = gtk_image_new_from_file ("./img/open_pl.png");
	gtk_button_set_image (GTK_BUTTON (open_pl), open_pl_icon);
	gtk_widget_set_tooltip_text (open_pl, "Open Playlist...");

	new_pl = gtk_button_new ();
	new_pl_icon = gtk_image_new_from_file ("./img/new_pl.png");
	gtk_button_set_image (GTK_BUTTON (new_pl), new_pl_icon);
	gtk_widget_set_tooltip_text (new_pl, "New Playlist");

	#ifdef unix
	load_pl = gtk_button_new ();
	load_pl_icon = gtk_image_new_from_file ("./img/load_pl.png");
	gtk_button_set_image (GTK_BUTTON (load_pl), load_pl_icon);
	gtk_widget_set_tooltip_text (load_pl, "Load Playlist...");

	save_pl = gtk_button_new ();
	save_pl_icon = gtk_image_new_from_file ("./img/save_pl.png");
	gtk_button_set_image (GTK_BUTTON (save_pl), save_pl_icon);
	gtk_widget_set_tooltip_text (save_pl, "Save Playlist...");
	#endif

	separate = gtk_vseparator_new ();

	loop = gtk_toggle_button_new ();
	loop_icon = gtk_image_new_from_file ("./img/loop.png");
	gtk_button_set_image (GTK_BUTTON (loop), loop_icon);
	gtk_widget_set_tooltip_text (loop, "Toggle Loop");

	shuffle = gtk_toggle_button_new ();
	shuffle_icon = gtk_image_new_from_file ("./img/shuffle.png");
	gtk_button_set_image (GTK_BUTTON (shuffle), shuffle_icon);
	gtk_widget_set_tooltip_text (shuffle, "Toggle Shuffle");

	// Create scales.
	seek_adjust = gtk_adjustment_new (INITIAL_VALUE,
					  MIN_VALUE, MAX_VALUE,
					  1, 5, 5);
	vol_adjust = gtk_adjustment_new (INITIAL_VALUE,
					 MIN_VALUE, 1,
					 .05, .05, .05);
	
	seek_bar = gtk_hscale_new (GTK_ADJUSTMENT (seek_adjust));
	gtk_scale_set_draw_value (GTK_SCALE (seek_bar), FALSE);
	gtk_range_set_update_policy (GTK_RANGE (seek_bar),
				     GTK_UPDATE_CONTINUOUS);

	volume_bar = gtk_hscale_new (GTK_ADJUSTMENT (vol_adjust));
	gtk_scale_set_draw_value (GTK_SCALE (volume_bar), FALSE);
	gtk_range_set_update_policy (GTK_RANGE (volume_bar),
				     GTK_UPDATE_CONTINUOUS);
	gtk_widget_set_size_request (volume_bar, 80, -1);

	// Pack widgets into their containers.
	gtk_container_add (GTK_CONTAINER (window), vbox);

	#ifdef GDK_WINDOWING_X11
	gtk_box_pack_start (GTK_BOX (vbox), video, TRUE, TRUE, 0);
	#endif

	gtk_box_pack_start (GTK_BOX (vbox), track_label, FALSE, FALSE, 2);
	gtk_box_pack_start (GTK_BOX (vbox), hbox_seek, FALSE, FALSE, 2);
	gtk_box_pack_start (GTK_BOX (hbox_seek), seek_bar, TRUE, TRUE, 2);
	gtk_box_pack_start (GTK_BOX (hbox_seek), seek_label, FALSE, FALSE, 2);
	gtk_box_pack_start (GTK_BOX (vbox), hbox_buttons, FALSE, FALSE, 2);
	gtk_box_pack_start (GTK_BOX (hbox_buttons), back, FALSE, FALSE, 2);
	gtk_box_pack_start (GTK_BOX (hbox_buttons), play, FALSE, FALSE, 2);
	gtk_box_pack_start (GTK_BOX (hbox_buttons), pause, FALSE, FALSE, 2);
	gtk_box_pack_start (GTK_BOX (hbox_buttons), stop, FALSE, FALSE, 2);
	gtk_box_pack_start (GTK_BOX (hbox_buttons), next, FALSE, FALSE, 2);
	gtk_box_pack_start (GTK_BOX (hbox_buttons), open_pl, FALSE, FALSE, 15);
	gtk_box_pack_start (GTK_BOX (hbox_buttons),
			    volume_icon,
			    FALSE,
			    FALSE,
			    2);
	gtk_box_pack_start (GTK_BOX (hbox_buttons),
			    volume_bar,
			    FALSE,
			    FALSE,
			    2);

	gtk_container_add (GTK_CONTAINER (pl_window), vbox_pl);
	gtk_box_pack_start (GTK_BOX (vbox_pl), scroll_pl, TRUE, TRUE, 2);
	gtk_box_pack_start (GTK_BOX (vbox_pl), hbox_pl, FALSE, FALSE, 2);
	gtk_box_pack_start (GTK_BOX (hbox_pl), new_pl, FALSE, FALSE, 2);
	gtk_box_pack_start (GTK_BOX (hbox_pl), add, FALSE, FALSE, 2);
	gtk_box_pack_start (GTK_BOX (hbox_pl), remove, FALSE, FALSE, 2);
	#ifdef unix
	gtk_box_pack_start (GTK_BOX (hbox_pl), load_pl, FALSE, FALSE, 2);
	gtk_box_pack_start (GTK_BOX (hbox_pl), save_pl, FALSE, FALSE, 2);
	#endif
	gtk_box_pack_start (GTK_BOX (hbox_pl), separate, FALSE, FALSE, 10);
	gtk_box_pack_start (GTK_BOX (hbox_pl), loop, FALSE, FALSE, 2);
	gtk_box_pack_start (GTK_BOX (hbox_pl), shuffle, FALSE, FALSE, 2);

	// Set up the playbin, the comment lines at the end of lines are used
	// for debugging error purposes.
	bin = gst_element_factory_make ("playbin", "bin");
	bus = gst_pipeline_get_bus (GST_PIPELINE (bin));
	video_sink = gst_element_factory_make ("ximagesink", "video_sink"); //
	g_object_set (G_OBJECT (video_sink), "force-aspect-ratio", TRUE, NULL);

	g_object_set (G_OBJECT (bin), "video-sink", video_sink, NULL); //

	g_object_set_data (G_OBJECT (bus), "stop", stop);
	g_object_set_data (G_OBJECT (bus), "playlist", playlist);
	g_object_set_data (G_OBJECT (bus), "pl_entries", pl_entries);
	g_object_set_data (G_OBJECT (bus), "window", window);
	g_object_set_data (G_OBJECT (bus), "video_sink", video_sink); //
	gst_bus_add_watch (bus, bus_message, bin);

	g_object_set_data (G_OBJECT (bin), "seek_label", seek_label);
	g_object_set_data (G_OBJECT (bin), "seek_bar", seek_bar);
	timeout_id = g_timeout_add (100,
			           (GSourceFunc) track_bar_callback,
		  	            GST_PIPELINE (bin));
	gst_object_unref (bus);

	// Set the volume slider to the value of volume.
	g_object_get (G_OBJECT (bin), "volume", &volume, NULL);
	gtk_range_set_value (GTK_RANGE (volume_bar), volume);

	// Connect signals to their callback functions.
	g_object_set_data (G_OBJECT (window), "stop", stop);
	g_signal_connect (G_OBJECT (window), "destroy",
			  G_CALLBACK (quit_program), NULL);

	g_object_set_data (G_OBJECT (pl_window), "open_pl", open_pl);
	g_signal_connect (G_OBJECT (pl_window), "delete-event",
			  G_CALLBACK (pl_delete), NULL);

	g_object_set_data (G_OBJECT (back), "bin", bin);
	g_object_set_data (G_OBJECT (back), "play", play);
	g_object_set_data (G_OBJECT (back), "playlist", playlist);
	g_object_set_data (G_OBJECT (back), "pl_entries", pl_entries);
	g_signal_connect (G_OBJECT (back), "clicked",
			  G_CALLBACK (back_button_clicked), NULL);

	g_object_set_data (G_OBJECT (play), "track_label", track_label);
	g_object_set_data (G_OBJECT (play), "playing_icon", playing_icon);
	g_object_set_data (G_OBJECT (play), "playlist", playlist);
	g_object_set_data (G_OBJECT (play), "pl_entries", pl_entries);
	g_object_set_data (G_OBJECT (play), "bin", bin);
	g_object_set_data (G_OBJECT (play), "window", window);
	g_signal_connect (G_OBJECT (play), "clicked",
			  G_CALLBACK (play_button_clicked), window);

	g_object_set_data (G_OBJECT (pause), "pl_entries", pl_entries);
	g_object_set_data (G_OBJECT (pause), "playing_icon", playing_icon);
	g_object_set_data (G_OBJECT (pause), "paused_icon", paused_icon);
	g_object_set_data (G_OBJECT (pause), "bin", bin);
	g_signal_connect (G_OBJECT (pause), "clicked",
			  G_CALLBACK (pause_button_clicked), NULL);

	g_object_set_data (G_OBJECT (stop), "track_label", track_label);
	g_object_set_data (G_OBJECT (stop), "playlist", playlist);
	g_object_set_data (G_OBJECT (stop), "pl_entries", pl_entries);
	g_object_set_data (G_OBJECT (stop), "seek_bar", seek_bar);
	g_object_set_data (G_OBJECT (stop), "seek_label", seek_label);
	g_object_set_data (G_OBJECT (stop), "bin", bin);
	g_object_set_data (G_OBJECT (stop), "window", window);
	g_signal_connect (G_OBJECT (stop), "clicked",
			  G_CALLBACK (stop_button_clicked), NULL);

	g_object_set_data (G_OBJECT (next), "bin", bin);
	g_object_set_data (G_OBJECT (next), "play", play);
	g_object_set_data (G_OBJECT (next), "playlist", playlist);
	g_object_set_data (G_OBJECT (next), "pl_entries", pl_entries);
	g_signal_connect (G_OBJECT (next), "clicked",
			  G_CALLBACK (next_button_clicked), NULL);

	g_object_set_data (G_OBJECT (add), "pl_entries", pl_entries);
	g_object_set_data (G_OBJECT (add), "window", window);
	g_signal_connect (G_OBJECT (add), "clicked",
			  G_CALLBACK (add_button_clicked), NULL);

	g_object_set_data (G_OBJECT (remove), "playlist", playlist);
	g_object_set_data (G_OBJECT (remove), "pl_entries", pl_entries);
	g_signal_connect (G_OBJECT (remove), "clicked",
			  G_CALLBACK (remove_button_clicked), NULL);

	g_object_set_data (G_OBJECT (open_pl), "pl_window", pl_window);
	g_signal_connect (G_OBJECT (open_pl), "toggled",
			  G_CALLBACK (open_pl_button_clicked), NULL);

	g_signal_connect (G_OBJECT (loop), "toggled",
			  G_CALLBACK (loop_button_clicked), NULL);
	g_signal_connect (G_OBJECT (shuffle), "toggled",
			  G_CALLBACK (shuffle_button_clicked), NULL);

	g_object_set_data (G_OBJECT (new_pl), "pl_entries", pl_entries);
	g_signal_connect (G_OBJECT (new_pl), "clicked",
			  G_CALLBACK (new_pl_button_clicked), NULL);

	#ifdef unix
	g_object_set_data (G_OBJECT (load_pl), "pl_window", pl_window);
	g_object_set_data (G_OBJECT (load_pl), "pl_entries", pl_entries);
	g_signal_connect (G_OBJECT (load_pl), "clicked",
			  G_CALLBACK (load_pl_button_clicked), NULL);

	g_object_set_data (G_OBJECT (save_pl), "pl_window", pl_window);
	g_object_set_data (G_OBJECT (save_pl), "pl_entries", pl_entries);
	g_object_set_data (G_OBJECT (save_pl), "playlist", playlist);
	g_signal_connect (G_OBJECT (save_pl), "clicked",
			  G_CALLBACK (save_pl_button_clicked), NULL);
	#endif

	g_object_set_data (G_OBJECT (playlist), "track_label", track_label);
	g_object_set_data (G_OBJECT (playlist), "play", play);
	g_object_set_data (G_OBJECT (playlist), "remove", remove);
	g_object_set_data (G_OBJECT (playlist), "pl_window", pl_window);
	g_object_set_data (G_OBJECT (playlist), "playing_icon", playing_icon);
	g_object_set_data (G_OBJECT (playlist), "pl_entries", pl_entries);
	g_object_set_data (G_OBJECT (playlist), "bin", bin);
	g_object_set_data (G_OBJECT (playlist), "window", window);
	g_signal_connect (playlist,
			  "row-activated",
			  G_CALLBACK (double_click_row),
			  NULL);
	g_signal_connect (playlist,
			  "cursor-changed",
			  G_CALLBACK (focus_change),
			  NULL);

	g_object_set_data (G_OBJECT (volume_bar), "bin", bin);
	g_signal_connect (G_OBJECT (volume_bar),
			  "value-changed",
			  G_CALLBACK (volume_changed),
			  NULL);

	g_object_set_data (G_OBJECT (seek_bar), "bin", bin);
	g_object_set_data (G_OBJECT (seek_bar), "window", window);
	g_signal_connect (G_OBJECT (seek_bar),
			  "value_changed",
			  G_CALLBACK (seek_changed),
			  NULL);

	g_signal_connect (playlist,
			  "button-press-event",
			  G_CALLBACK (on_button_press),
			  NULL);
	g_signal_connect (playlist,
			  "popup-menu",
			  G_CALLBACK (playlist_popup),
			  NULL);

	// Show the window and all of its children.
	gtk_widget_show_all (window);

	// Code specific to environments using the X Window System.
	#ifdef GDK_WINDOWING_X11
	// Connect window state event to check for fullscreen.
	g_object_set_data (G_OBJECT (video), "window", window);
	g_object_set_data (G_OBJECT (video), "hbox_seek", hbox_seek);
	g_object_set_data (G_OBJECT (video), "hbox_buttons",
			   hbox_buttons);
	g_object_set_data (G_OBJECT (video), "track_label",
			   track_label);
	g_signal_connect (window, "window-state-event",
			  G_CALLBACK (window_fullscreen), NULL); 

	g_object_set_data (G_OBJECT (window), "open_pl", open_pl);
	g_object_set_data (G_OBJECT (window), "pause", pause);
	g_object_set_data (G_OBJECT (window), "hbox_seek", hbox_seek);
	g_object_set_data (G_OBJECT (window), "hbox_buttons",
			   hbox_buttons);
	g_object_set_data (G_OBJECT (window), "track_label",
			   track_label);
	g_signal_connect (window, "key-press-event",
			  G_CALLBACK (catch_window_key), NULL);
	g_signal_connect (window, "motion-notify-event",
			  G_CALLBACK (window_motion), NULL);

	// Realize the window to get the window XID.
	gtk_widget_realize (video);
	g_assert (video_window_xid != 0);

	// Since XID needs to be set immediately, the sync handler
	// needs to be called once it's received.
	bus = gst_pipeline_get_bus (GST_PIPELINE (bin));
	gst_bus_set_sync_handler (bus, (GstBusSyncHandler) bus_sync,
				  NULL);
	gst_object_unref (bus);
	#endif

	// Start the main GTK loop.
	gtk_main();

	// Clean up.
	gst_element_set_state (bin, GST_STATE_NULL);
	gst_object_unref (GST_OBJECT (bin));
	gtk_tree_path_free (playing);

	return 0;
}

// Callback function when the back button is clicked.
static void back_button_clicked (GtkWidget *widget, gpointer data)
{
	GtkListStore *pl_entries;
	GtkWidget *playlist, *play;
	GstState state;
	GstElement *bin;
	GtkTreeModel *model;
	GtkTreeIter temp;
	GtkTreePath *cursor;

	bin = g_object_get_data (G_OBJECT (widget), "bin");
	bin = (GstElement *) bin;

	gst_element_get_state (bin, &state, NULL, GST_SECOND);

	play = g_object_get_data (G_OBJECT (widget), "play");
	playlist = g_object_get_data (G_OBJECT (widget), "playlist");
	pl_entries = g_object_get_data (G_OBJECT (widget), "pl_entries");

	model = gtk_tree_view_get_model (GTK_TREE_VIEW (playlist));

	gtk_tree_view_get_cursor (GTK_TREE_VIEW (playlist), &cursor, NULL);

	// Test for an empty list or if nothing is selected.
	if (cursor == NULL ||
	    gtk_tree_model_get_iter_first (model, &temp) == FALSE)
		return;

	// If the track is already playing, go back and play the track before,
	// otherwise just change the cursor.
	if (g_strcmp0
	   (gst_element_state_get_name (state), "NULL") == 0 ||
	    g_strcmp0
	   (gst_element_state_get_name (state), "READY") == 0)
	{
		GtkTreePath *current;
		
		current = gtk_tree_model_get_path (model, &selected);

		if (gtk_tree_path_prev (current))
			gtk_tree_view_set_cursor
					(GTK_TREE_VIEW (playlist),
					 current,
					 NULL,
					 FALSE);
	}
	else
	{
		if (gtk_tree_path_prev (playing))
			gtk_tree_view_set_cursor
					(GTK_TREE_VIEW (playlist),
					 playing,
					 NULL,
					 FALSE);

		gtk_button_clicked (GTK_BUTTON (play));
	}
}

// Callback function when the play button is clicked.
static void play_button_clicked (GtkWidget *widget, gpointer data)
{
	GstElement *bin;
	GstState state;
	GtkWidget *playlist, *track_label;
	GtkListStore *pl_entries;
	GtkTreePath *path;
	GdkPixbuf *playing_icon;
	GtkTreeIter iter, validity_test;
	GtkTreeModel *model;

	track_label = g_object_get_data (G_OBJECT (widget), "track_label");
	playlist = g_object_get_data (G_OBJECT (widget), "playlist");
	pl_entries = g_object_get_data (G_OBJECT (widget), "pl_entries");
	playing_icon = g_object_get_data (G_OBJECT (widget), "playing_icon");
	bin = g_object_get_data (G_OBJECT (widget), "bin");
	bin = (GstElement *) bin; 

	model = gtk_tree_view_get_model (GTK_TREE_VIEW (playlist));
	gtk_tree_view_get_cursor (GTK_TREE_VIEW (playlist), &path, NULL);

	gst_element_get_state (bin, &state, NULL, GST_SECOND);

	if (g_strcmp0
	   (gst_element_state_get_name (state), "PAUSED") == 0)
	{
		gst_element_set_state (bin, GST_STATE_PLAYING);
		return;
	}

	if (gtk_tree_model_get_iter_first (model, &validity_test) == FALSE)
		return;

	// If nothing is selected, play the first track.
	if (path == NULL)
	{
		if (gtk_tree_model_get_iter_first (model, &iter))
		{
			path = gtk_tree_model_get_path (model, &iter);
			selected = iter;
			gtk_tree_view_set_cursor (GTK_TREE_VIEW (playlist),
						  path,
						  NULL,
						  FALSE);
		}
	}

	// Play and set pixbuf if something is selected.
	if (path != NULL)
	{
		gchar *label;

		clear_pixbuf (pl_entries, GTK_TREE_VIEW (playlist));

		gtk_list_store_set (pl_entries,
				    &selected,
				    COL_PLAYING, playing_icon,
				    -1);
		gtk_tree_model_get (model, &selected,
				    COL_TRACK_NAME, &label, -1);
		gtk_label_set_text (GTK_LABEL (track_label), label);

		gst_element_set_state (bin, GST_STATE_NULL);
		gst_element_set_state (bin, GST_STATE_PLAYING);

		gtk_tree_model_get_iter (model, &selected, path);
		playing = path;

		g_free (label);
	}

	gst_element_get_state (bin, &state, NULL, GST_SECOND * 2);

	// For X Windows, sets the size of the window when video is played.
	#ifdef GDK_WINDOWING_X11
		GtkWidget *window;
		GList *stream_list;	// Stream info list.
		GObject *stream;	// Playing stream.
		GstObject *pad;		// The video pad.
		gint playing_video;	// Whether a video is playing.
		gint width = 0, height = 0;	// Width and height of video.

		window = g_object_get_data (G_OBJECT (widget), "window");

		g_object_get (G_OBJECT (bin), "stream-info",
			      &stream_list, NULL);
		stream = g_list_nth_data (stream_list, 0);
		g_object_get (G_OBJECT (stream), "object", &pad, NULL);

		g_object_get (G_OBJECT (bin), "current-video",
			      &playing_video, NULL);

		if (playing_video > -1 &&
		    gst_video_get_size (GST_PAD (pad), &width, &height))
			gtk_window_resize (GTK_WINDOW (data),
					   width,
					   height + WIN_HEIGHT);
		else if (playing_video == -1)
			gtk_window_resize (GTK_WINDOW (data),
					   WIN_WIDTH,
					   WIN_HEIGHT);
	#endif
}

// Callback function when the pause button is clicked.
static void pause_button_clicked (GtkWidget *widget, gpointer data)
{
	GstElement *bin;
	GstState state;
	GtkListStore *pl_entries;
	GdkPixbuf *playing_icon, *paused_icon;

	pl_entries = g_object_get_data (G_OBJECT (widget), "pl_entries");
	playing_icon = g_object_get_data (G_OBJECT (widget), "playing_icon");
	paused_icon = g_object_get_data (G_OBJECT (widget), "paused_icon");

	bin = g_object_get_data (G_OBJECT (widget), "bin");
	bin = (GstElement *) bin;

	gst_element_get_state (bin, &state, NULL, GST_SECOND);

	// If already playing, pause, if paused, start playing.
	if (g_strcmp0
	   (gst_element_state_get_name (state), "PAUSED") == 0)
	{
		gst_element_set_state (bin, GST_STATE_PLAYING);
	}
	else if (g_strcmp0
		(gst_element_state_get_name (state), "PLAYING") == 0)
	{
		gst_element_set_state (bin, GST_STATE_PAUSED);
	}
}

// Callback function for the stop button.
static void stop_button_clicked (GtkWidget *widget, gpointer data)
{
	GstElement *bin;
	GstState state;
	GtkWidget *playlist, *seek_bar, *seek_label, *track_label;
	GtkListStore *pl_entries;

	track_label = g_object_get_data (G_OBJECT (widget), "track_label");
	playlist = g_object_get_data (G_OBJECT (widget), "playlist");
	pl_entries = g_object_get_data (G_OBJECT (widget), "pl_entries");
	seek_bar = g_object_get_data (G_OBJECT (widget), "seek_bar");
	seek_label = g_object_get_data (G_OBJECT (widget), "seek_label");

	bin = g_object_get_data (G_OBJECT (widget), "bin");
	bin = (GstElement *) bin;

	gst_element_set_state (bin, GST_STATE_NULL);

	gst_element_get_state (bin, &state, NULL, GST_SECOND);

	// Remove pixbufs from first column and set seek bar and label to 0.
	if (g_strcmp0
	    (gst_element_state_get_name (state), "NULL") == 0)
	{
		clear_pixbuf (pl_entries, GTK_TREE_VIEW (playlist));

		gtk_range_set_value (GTK_RANGE (seek_bar), 0);
		gtk_label_set_text (GTK_LABEL (seek_label), "--:--:-- / --:--:--");
		gtk_label_set_text (GTK_LABEL (track_label), "No Track Selected");
		playing = NULL;

		#ifdef GDK_WINDOWING_X11
		GtkWidget *window;

		window = g_object_get_data (G_OBJECT (widget), "window");
		gtk_window_unfullscreen (GTK_WINDOW (window));
		gtk_window_unmaximize (GTK_WINDOW (window));
		gtk_window_resize (GTK_WINDOW (window),
				   WIN_WIDTH,
				   WIN_HEIGHT);
		#endif
	}
}

// Callback function for the next button.
static void next_button_clicked (GtkWidget *widget, gpointer data)
{
	GtkListStore *pl_entries;
	GtkWidget *playlist, *play;
	GstState state;
	GstElement *bin;
	GtkTreeModel *model;
	GtkTreeIter temp, validity_test;
	GtkTreePath *cursor;
	GtkTreeSelection *selection;

	bin = g_object_get_data (G_OBJECT (widget), "bin");
	bin = (GstElement *) bin;

	gst_element_get_state (bin, &state, NULL, GST_SECOND);

	play = g_object_get_data (G_OBJECT (widget), "play");
	playlist = g_object_get_data (G_OBJECT (widget), "playlist");
	pl_entries = g_object_get_data (G_OBJECT (widget), "pl_entries");

	model = gtk_tree_view_get_model (GTK_TREE_VIEW (playlist));

	gtk_tree_view_get_cursor (GTK_TREE_VIEW (playlist), &cursor, NULL);
	selection = gtk_tree_view_get_selection (GTK_TREE_VIEW (playlist));

	// Test for an empty list or if nothing is selected.
	if (cursor == NULL ||
	    gtk_tree_model_get_iter_first (model, &temp) == FALSE)
		return;

	// Play the next song if something is already playing, otherwise just
	// select the next song.
	if (g_strcmp0
	    (gst_element_state_get_name (state), "NULL") == 0 ||
	    g_strcmp0
	    (gst_element_state_get_name (state), "READY") == 0)
	{
		GtkTreePath *current;

		// Select something at random if shuffle is true;
		if (shuffle == TRUE)
		{
			if (!gtk_tree_model_get_iter_first (model,
							    &validity_test))
				return;

			if (gtk_tree_model_iter_nth_child (model,
							   &validity_test,
							   NULL,
							   rand () % num_tracks))
				current = gtk_tree_model_get_path (model,
								   &validity_test);
				
			gtk_tree_view_set_cursor (GTK_TREE_VIEW (playlist),
				 		  current,
						  NULL,
						  FALSE);
			return;
		}
	
		current = gtk_tree_model_get_path (model, &selected);

		gtk_tree_model_get_iter (model, &validity_test, cursor);
		// If next iterator is not valid, go to beginning if loop is
		// TRUE. Otherwise, return.
		if (gtk_tree_model_iter_next (model, &validity_test) == FALSE)
		{ // start if 1
			if (!gtk_list_store_iter_is_valid (pl_entries,
							   &validity_test) &&
			    loop == TRUE)
			{ // start if 2
				if (!gtk_tree_model_get_iter_first (model,
								    &validity_test))
					return;

				current = gtk_tree_model_get_path (model,
								   &validity_test);					
			} // end if 2
			else
				return;
		} // end if 1
		else
			gtk_tree_path_next (current);

		gtk_tree_view_set_cursor
				(GTK_TREE_VIEW (playlist),
				 current,
				 NULL,
				 FALSE);
	}
	else
	{
		// Play something at random if shuffle is true;
		if (shuffle == TRUE)
		{
			GtkTreePath *current;

			if (!gtk_tree_model_get_iter_first (model,
							    &validity_test))
				return;

			if (gtk_tree_model_iter_nth_child (model,
							   &validity_test,
							   NULL,
							   rand () % num_tracks))
				current = gtk_tree_model_get_path (model,
								   &validity_test);
				
			gtk_tree_view_set_cursor (GTK_TREE_VIEW (playlist),
				 		  current,
						  NULL,
						  FALSE);

			gtk_tree_view_row_activated (GTK_TREE_VIEW (playlist),
						     current,
						     NULL);
			return;
		}

		// If there is a next song, play it.
		gtk_tree_model_get_iter (model, &temp, playing);

		if (gtk_list_store_iter_is_valid (pl_entries, &temp) &&
		    gtk_tree_model_iter_next (model, &temp))
		{
			gtk_tree_path_next (playing);
			gtk_tree_view_set_cursor
				(GTK_TREE_VIEW (playlist),
				 playing,
				 NULL,
				 FALSE);

			gtk_tree_view_row_activated
				(GTK_TREE_VIEW (playlist),
			 	 playing,
				 NULL);
		} // end if

		// If there is no next song but loop is on, loop around.
		else if (loop == TRUE &&
			 !gtk_list_store_iter_is_valid (pl_entries, &temp))
		{
			if (gtk_tree_model_get_iter_first (model,
							   &temp))
			{
				//gtk_tree_selection_select_iter (selection,
				//				&temp);

				playing = gtk_tree_model_get_path (model,
								   &temp);

				gtk_tree_view_set_cursor (GTK_TREE_VIEW (playlist),
				 			  playing,
							  NULL,
							  FALSE);

				gtk_tree_view_row_activated
					(GTK_TREE_VIEW (playlist),
					 playing,
					 NULL);
			}
		}
	} // end else
}

// Callback function when the open/add button is clicked.
static void add_button_clicked (GtkWidget *widget, gpointer data)
{
	GtkWidget *dialog, *window;

	window = g_object_get_data (G_OBJECT (widget), "window");

	dialog = gtk_file_chooser_dialog_new ("Open File",
					      GTK_WINDOW (window),
					      GTK_FILE_CHOOSER_ACTION_OPEN,
					      GTK_STOCK_CANCEL,
					      GTK_RESPONSE_CANCEL,
					      GTK_STOCK_OPEN,
					      GTK_RESPONSE_ACCEPT,
					      NULL);
	if (gtk_dialog_run (GTK_DIALOG (dialog)) == GTK_RESPONSE_ACCEPT)
	{
		tag_info track_info;
		GtkListStore *pl_entries;
		gchar *uri, *filename;

		pl_entries = g_object_get_data (G_OBJECT (widget),
						"pl_entries");

		// Get the URI of the file.
		uri = gtk_file_chooser_get_uri (GTK_FILE_CHOOSER (dialog));

		// Get the file path.
		filename = gtk_file_chooser_get_filename
			(GTK_FILE_CHOOSER (dialog));

		#ifdef WIN32
		filename = g_locale_from_utf8 (filename, -1, NULL, NULL, NULL);
		#endif

		#ifdef unix
		// Parse playlist if a playlist file is added.
		if (parse_pl (uri, pl_entries) ==
					TOTEM_PL_PARSER_RESULT_SUCCESS)
		{
			g_free (uri);
			g_free (filename);
			gtk_widget_destroy (dialog);
			return;
		}
		#endif

		// Parse file of its tag info.
		if (parse_tag (filename, &track_info))
			add_data_at_end (pl_entries,
					 track_info,
					 uri,
					 filename);
		else
		{
			// Using this causes Windows to crash, so it will set
			// it to the full path on Windows machines.
			track_info.title = strrchr (filename, '/') + 1;

			#ifdef WIN32
			track_info.title = filename;
			#endif

			track_info.artist = "";
			g_sprintf (track_info.length, "??:??");
			add_data_at_end (pl_entries,
					 track_info,
					 uri,
					 filename);
		}
		
		g_free (uri);
		g_free (filename);
	}

	gtk_widget_destroy (dialog);
}

// Callback for remove button to remove currently selected item from list.
static void remove_button_clicked (GtkWidget *widget, gpointer data)
{
	GtkWidget *playlist;
	GtkListStore *pl_entries;
	GtkTreeModel *model;
	GtkTreeIter iter;
	GtkTreeSelection *selection;

	playlist = g_object_get_data (G_OBJECT (widget), "playlist");
	pl_entries = g_object_get_data (G_OBJECT (widget), "pl_entries");

	selection = gtk_tree_view_get_selection (GTK_TREE_VIEW (playlist));
	// Remove the selected element.
	if (gtk_tree_selection_get_selected (selection, &model, &iter))
	{
		gtk_list_store_remove (pl_entries, &iter);
	}

}

// Callback function when the open playlist button is clicked.
static void open_pl_button_clicked (GtkWidget *widget, gpointer data)
{
	GtkWidget *pl_window;

	pl_window = g_object_get_data (G_OBJECT (widget), "pl_window");

	if (gtk_toggle_button_get_active (GTK_TOGGLE_BUTTON (widget)))
		gtk_widget_show_all (pl_window);
	else
		gtk_widget_hide_all (pl_window);
}

static void loop_button_clicked (GtkWidget *widget, gpointer data)
{
	if (gtk_toggle_button_get_active (GTK_TOGGLE_BUTTON (widget)))
		loop = TRUE;
	else
		loop = FALSE;

	printf ("Loop: %i\n", loop);
}

static void shuffle_button_clicked (GtkWidget *widget, gpointer data)
{
	if (gtk_toggle_button_get_active (GTK_TOGGLE_BUTTON (widget)))
		shuffle = TRUE;
	else
		shuffle = FALSE;

	printf ("Shuffle: %i\n", shuffle);
}

// Hide the playlist when destroyed rather than delete it.
static gboolean pl_delete (GtkWidget *widget, gpointer data)
{
	GtkWidget *open_pl;
	
	open_pl = g_object_get_data (G_OBJECT (widget), "open_pl");

	gtk_widget_hide_all (widget);
	gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (open_pl), FALSE);

	return TRUE;
}

// Removes the playlist entries.
void new_pl_button_clicked (GtkWidget *widget, gpointer data)
{
	GtkListStore *pl_entries;

	pl_entries = g_object_get_data (G_OBJECT (widget), "pl_entries");

	gtk_list_store_clear (pl_entries);
}

#ifdef unix
// Parses a playlist, returns FALSE if not a playlist.
TotemPlParserResult parse_pl (gchar *uri, GtkListStore *pl_entries)
{
	TotemPlParser *pl_parser;
	TotemPlParserResult result;

	pl_parser = totem_pl_parser_new ();

	g_object_set_data (G_OBJECT (pl_parser), "pl_entries", pl_entries);
	g_signal_connect (pl_parser, "entry-parsed",
			  G_CALLBACK (parsed_entry), NULL);

	result = totem_pl_parser_parse (pl_parser, uri, FALSE);
	return result;
}

// Parses an entry and adds it to the playlist.
static void parsed_entry (TotemPlParser *parser,
			  gchar *uri,
			  GHashTable *metadata,
			  gchar data)
{
	gchar *filename, *f_to_uri;
	tag_info track_info;
	GtkListStore *pl_entries;

	pl_entries = g_object_get_data (G_OBJECT (parser), "pl_entries");

	// Get the filename of the track file.
	filename =  gnome_vfs_get_local_path_from_uri (uri);
	
	// The first if statement is mainly for M3U's, since they don't use
	// URI's. Otherwise, just check if it's an invalid entry.
	if (filename == NULL)
	{
		f_to_uri = gnome_vfs_get_uri_from_local_path (uri);
		filename = gnome_vfs_get_local_path_from_uri (f_to_uri);

		if (filename == NULL)
			return;
	}

	// Parse file of its tag info.
	if (parse_tag (filename, &track_info))
	{
		add_data_at_end (pl_entries,
				 track_info,
				 uri,
				 filename);
	}
	else
	{
		// Using this causes Windows to crash, so it will set
		// it to the full path on Windows machines.
		track_info.title = strrchr (filename, '/') + 1;

		#ifdef WIN32
		track_info.title = filename;
		#endif

		track_info.artist = "";
		g_sprintf (track_info.length, "??:??");

		add_data_at_end (pl_entries,
				 track_info,
				 uri,
				 filename);
	}

	g_free (filename);
}

// Loads a playlist and clears the old playlist.
static void load_pl_button_clicked (GtkWidget *widget, gpointer data)
{
	GtkWidget *dialog, *pl_window;
	GtkFileFilter *format_playlist;

	pl_window = g_object_get_data (G_OBJECT (widget), "pl_window");

	// Set file filter specifications.
	format_playlist = gtk_file_filter_new ();
	gtk_file_filter_set_name (format_playlist,
				  "Playlist Files (*.m3u;*.pls;*.xspf)");
	gtk_file_filter_add_pattern (format_playlist, "*.m3u");
	gtk_file_filter_add_pattern (format_playlist, "*.pls");
	gtk_file_filter_add_pattern (format_playlist, "*.xspf");

	dialog = gtk_file_chooser_dialog_new ("Open File",
					      GTK_WINDOW (pl_window),
					      GTK_FILE_CHOOSER_ACTION_OPEN,
					      GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,
					      GTK_STOCK_OPEN, GTK_RESPONSE_ACCEPT,
					      NULL);
	gtk_file_chooser_add_filter (GTK_FILE_CHOOSER (dialog), format_playlist);

	if (gtk_dialog_run (GTK_DIALOG (dialog)) == GTK_RESPONSE_ACCEPT)
  	{
	    	char *uri;
    		uri = gtk_file_chooser_get_uri
					(GTK_FILE_CHOOSER (dialog));

		GtkListStore *pl_entries;

		pl_entries = g_object_get_data
					(G_OBJECT (widget), "pl_entries");

		// Clear the old playlist and load the new one if the file is
		// a valid playlist.
		gtk_list_store_clear (pl_entries);

		if (parse_pl (uri, pl_entries) !=
					TOTEM_PL_PARSER_RESULT_SUCCESS)
			error_dialog (pl_window, "Not a valid playlist.");

		g_free (uri);
  	}

	gtk_widget_destroy (dialog);
}

// Prompts user for a filename and saves a playlist.
static void save_pl_button_clicked (GtkWidget *widget, gpointer data)
{
	GtkWidget *dialog, *pl_window, *playlist;
	GtkTreeModel *model;
	GtkTreeIter playlist_iter;
	GtkFileFilter *format_playlist;

	pl_window = g_object_get_data (G_OBJECT (widget), "pl_window");
	playlist = g_object_get_data (G_OBJECT (widget), "playlist");

	model = gtk_tree_view_get_model (GTK_TREE_VIEW (playlist));

	// Set file filter specifications.
	format_playlist = gtk_file_filter_new ();
	gtk_file_filter_set_name (format_playlist,
				  "Playlist Files (*.m3u;*.pls;*.xspf)");
	gtk_file_filter_add_pattern (format_playlist, "*.m3u");
	gtk_file_filter_add_pattern (format_playlist, "*.pls");
	gtk_file_filter_add_pattern (format_playlist, "*.xspf");

	dialog = gtk_file_chooser_dialog_new ("Save File",
					      GTK_WINDOW (pl_window),
					      GTK_FILE_CHOOSER_ACTION_SAVE,
					      GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,
					      GTK_STOCK_SAVE, GTK_RESPONSE_ACCEPT,
					      NULL);

	gtk_file_chooser_add_filter (GTK_FILE_CHOOSER (dialog), format_playlist);
	gtk_file_chooser_set_do_overwrite_confirmation (GTK_FILE_CHOOSER (dialog),
							TRUE);
	gtk_file_chooser_set_current_name (GTK_FILE_CHOOSER (dialog),
					   "Untitled.pls");

	if (gtk_dialog_run (GTK_DIALOG (dialog)) == GTK_RESPONSE_ACCEPT)
	{
		gchar *filename, *extension;
		GtkListStore *pl_entries;
		TotemPlParser *save_playlist;
		gint type;

		pl_entries = g_object_get_data
					(G_OBJECT (widget), "pl_entries");
		save_playlist = totem_pl_parser_new ();

		// Get the filename and its extension, if not a valid playlist
		// extension, use pls format.
		filename = gtk_file_chooser_get_filename
					(GTK_FILE_CHOOSER (dialog));
		extension = strrchr (filename, '.') + 1;

		if (g_strcmp0 (extension, "pls") == 0)
			type = TOTEM_PL_PARSER_PLS;
		else if (g_strcmp0 (extension, "m3u") == 0)
			type = TOTEM_PL_PARSER_M3U;
		else if (g_strcmp0 (extension, "xspf") == 0)
			type = TOTEM_PL_PARSER_XSPF;
		else if (g_strcmp0 (extension, "pla") == 0)
			type = TOTEM_PL_PARSER_IRIVER_PLA;
		else
			type = TOTEM_PL_PARSER_PLS;

		// Use this code for Totem Playlist Parser 2.28 and down.
		if (totem_pl_parser_write (save_playlist, model, save_parser,
				       	   filename, type, NULL, NULL) != TRUE)
			error_dialog (pl_window,
				      "Error occurred while saving playlist.");
		// End code for 2.28.

		// Use this code for Totem Playlist Parser 2.30+
		/*TotemPlPlaylist *list_to_save;
		TotemPlPlaylistIter pl_iter;
		GFile *file;
		gchar *uri, *title;

		list_to_save = totem_pl_playlist_new ();
		file = g_file_new_for_path (filename);

		if (gtk_tree_model_get_iter_first (model, &playlist_iter))
		{
			// Get and set the first element of the playlist.
			gtk_tree_model_get (model, &playlist_iter,
					    COL_URI, &uri,
					    COL_TRACK_NAME, &title,
					    -1);

			totem_pl_playlist_append (list_to_save, &pl_iter);
			
			totem_pl_playlist_set (list_to_save, &pl_iter,
					       TOTEM_PL_PARSER_FIELD_URI, uri,
					       TOTEM_PL_PARSER_FIELD_TITLE,
					       title, NULL);

			// Now get and set the rest of the playlist.
			while (gtk_tree_model_iter_next
						(model, &playlist_iter))
			{
				gtk_tree_model_get (model, &playlist_iter,
						    COL_URI, &uri,
						    COL_TRACK_NAME, &title,
						    -1);

				totem_pl_playlist_append (list_to_save,
							  &pl_iter);
			
				totem_pl_playlist_set (list_to_save,
						       &pl_iter,
						       TOTEM_PL_PARSER_FIELD_URI,
						       uri,
						       TOTEM_PL_PARSER_FIELD_TITLE,
						       title, NULL);
			}

			if (totem_pl_parser_save (save_playlist, list_to_save,
						  file, NULL,
						  type, NULL) != TRUE)
				error_dialog (pl_window,
				      "Error occurred while saving playlist.");

		}*/
		// End code for 2.30.
		

	    g_free (filename);
	}
	gtk_widget_destroy (dialog);
}

// Parses the tree model entries for saving playlist.
void save_parser (GtkTreeModel *model, GtkTreeIter *iter, gchar **uri,
		  gchar **title, gboolean *custom_title, gpointer data)
{
	gtk_tree_model_get (model, iter, COL_URI, uri,
					 COL_TRACK_NAME, title,
					-1);
	*custom_title = TRUE;
}
#endif

// Callback function for when the pipeline gets a message.
static gboolean bus_message (GstBus *bus, GstMessage *message, gpointer data)
{
	GtkWidget *window, *playlist, *stop;
	GtkListStore *pl_entries;
	GtkTreeSelection *selection;

	stop = g_object_get_data (G_OBJECT (bus), "stop");
	window = g_object_get_data (G_OBJECT (bus), "window");
	playlist = g_object_get_data (G_OBJECT (bus), "playlist");
	pl_entries = g_object_get_data (G_OBJECT (bus), "pl_entries");

	selection = gtk_tree_view_get_selection (GTK_TREE_VIEW (playlist));

	switch (GST_MESSAGE_TYPE (message))
	{
		// If an error has occurred, output the error on the console
		// and quit.
		case GST_MESSAGE_ERROR:
		{
			GError *err;

			gst_message_parse_error (message, &err, NULL);
			error_dialog (window, err -> message);
			g_error_free (err);
			break;

		}

		// Otherwise, in case of end of stream, go to the next song.
		case GST_MESSAGE_EOS:
		{
			GtkTreeIter temp, validity_test;
			GtkTreeModel *model;

			model = gtk_tree_view_get_model
					(GTK_TREE_VIEW (playlist));
			gtk_tree_model_get_iter (model, &temp, playing);

			// Play something at random if shuffle is true;
			if (shuffle == TRUE)
			{
				GtkTreePath *current;

				if (!gtk_tree_model_get_iter_first (model,
								    &validity_test))
					return TRUE;

				if (gtk_tree_model_iter_nth_child (model,
								   &validity_test,
								   NULL,
								   rand () % num_tracks))
					current = gtk_tree_model_get_path (model,
									   &validity_test);
				
				gtk_tree_view_set_cursor (GTK_TREE_VIEW (playlist),
					 		  current,
							  NULL,
							  FALSE);

				gtk_tree_view_row_activated (GTK_TREE_VIEW (playlist),
							     current,
							     NULL);
				playing = current;

				return TRUE;
			}

			// If there is a next song, play it.
			if (gtk_list_store_iter_is_valid (pl_entries, &temp) &&
			    gtk_tree_model_iter_next (model, &temp))
			{
				gtk_tree_path_next (playing);
				gtk_tree_view_set_cursor
					(GTK_TREE_VIEW (playlist),
					 playing,
					 NULL,
					 FALSE);

				gtk_tree_view_row_activated
					(GTK_TREE_VIEW (playlist),
				 	 playing,
					 NULL);
			}
			// If there is no next song but loop is on, loop around.
			else if (loop == TRUE &&
				 !gtk_list_store_iter_is_valid (pl_entries, &temp))
			{
				if (gtk_tree_model_get_iter_first (model,
							   &temp))
				{
					//gtk_tree_selection_select_iter (selection,
					//				&temp);

					playing = gtk_tree_model_get_path (model,
									   &temp);

					gtk_tree_view_set_cursor (GTK_TREE_VIEW (playlist),
					 			  playing,
								  NULL,
								  FALSE);

					gtk_tree_view_row_activated
						(GTK_TREE_VIEW (playlist),
						 playing,
						 NULL);
				}
				else
					gtk_button_clicked (GTK_BUTTON (stop)); 
			}
			else
				gtk_button_clicked (GTK_BUTTON (stop));

			break;
		}

		case GST_MESSAGE_TAG:
		{
			//GstTagList *tag, *temp;

			//gst_message_parse_tag (message, &temp);
			//printf ("A TAG WAS FOUND.\n");
			break;
		}

		default:
			break;
	}

	return TRUE;
}

// Function called on an error.
void error_dialog (GtkWidget *parent, gchar *error_text)
{
	GtkWidget *error, *label, *image, *hBox;

	// Create a new dialog box with one button.
	error = gtk_dialog_new_with_buttons ("Error",
					     GTK_WINDOW (parent),
					     GTK_DIALOG_MODAL,
					     GTK_STOCK_OK,
					     GTK_RESPONSE_OK,
					     NULL);

	// Remove the separator above the buttons.
	gtk_dialog_set_has_separator (GTK_DIALOG (error), FALSE);

	// Create the label, image, and the horizontal box and set properties.
	label = gtk_label_new (error_text);

	image = gtk_image_new_from_stock (GTK_STOCK_DIALOG_ERROR,
					  GTK_ICON_SIZE_DIALOG);
	hBox = gtk_hbox_new (FALSE, 10);
	gtk_container_set_border_width (GTK_CONTAINER (hBox), 15);

	// Pack the two widgets into the horizontal box.
	gtk_box_pack_start_defaults (GTK_BOX (hBox), image);
	gtk_box_pack_start_defaults (GTK_BOX (hBox), label);
	
	// Pack the horizontal box into the dialog box.
	gtk_box_pack_start_defaults (GTK_BOX (GTK_DIALOG (error)->vbox), hBox);
	
	// Show the widgets, and exit on clicking the OK button.
	gtk_widget_show_all (error);

	gtk_dialog_run (GTK_DIALOG (error));
	gtk_widget_destroy (error);
}

// Used for creating the tree view.
static GtkWidget *create_treeview (GtkListStore *list)
{
	GtkWidget *treeview;
	GtkCellRenderer *renderer;
	GtkTreeModel *model;
	GtkTreeViewColumn *column;

	treeview = gtk_tree_view_new ();

	// Create the playing column.
	renderer = gtk_cell_renderer_pixbuf_new ();
	gtk_tree_view_insert_column_with_attributes (GTK_TREE_VIEW (treeview),
						     -1,
						     "",
						     renderer,
						     "pixbuf", COL_PLAYING,
						     NULL);

	column = gtk_tree_view_get_column (GTK_TREE_VIEW (treeview),
					   COL_PLAYING);
	gtk_tree_view_column_set_sizing (column, GTK_TREE_VIEW_COLUMN_FIXED);
	gtk_tree_view_column_set_fixed_width (column, 32);

	// Create the artist column.
	renderer = gtk_cell_renderer_text_new ();
	//g_object_set (G_OBJECT (renderer), "size-points", 5, NULL);
	gtk_tree_view_insert_column_with_attributes (GTK_TREE_VIEW (treeview),
						     -1,
						     "Track Name",
						     renderer,
						     "text", COL_TRACK_NAME,
						     NULL);

	column = gtk_tree_view_get_column (GTK_TREE_VIEW (treeview),
					   COL_TRACK_NAME);
	gtk_tree_view_column_set_sizing (column, GTK_TREE_VIEW_COLUMN_FIXED);
	gtk_tree_view_column_set_fixed_width (column, 305);

	// Create the length column.
	renderer = gtk_cell_renderer_text_new ();
	gtk_tree_view_insert_column_with_attributes (GTK_TREE_VIEW (treeview),
						     -1,
						     "Length",
						     renderer,
						     "text", COL_LENGTH,
						     NULL);

	column = gtk_tree_view_get_column (GTK_TREE_VIEW (treeview),
					   COL_LENGTH);
	gtk_tree_view_column_set_sizing (column, GTK_TREE_VIEW_COLUMN_FIXED);
	gtk_tree_view_column_set_fixed_width (column, 40);
	gtk_tree_view_column_set_alignment (column, 0);

	model = GTK_TREE_MODEL (list);
	gtk_tree_view_set_model (GTK_TREE_VIEW (treeview), model);

	g_signal_connect (G_OBJECT (model),
			  "row-deleted",
			  G_CALLBACK (on_row_delete),
			  NULL);

	g_object_unref (model);

	return treeview;
}

// Add data to the end of a tree list.
void add_data_at_end (GtkListStore *list,
		      tag_info tag,
		      gchar* uri,
		      gchar* filename)
{
	GtkTreeIter iter;
	gchar *track_name;

	track_name = calloc (MAX_CHARS * 2, sizeof (gchar));

	// Concatenate artist and title if the artist is not empty.
	if (g_strcmp0 (tag.artist, "") == 0)
		track_name = g_strconcat (tag.title, NULL);
		//g_sprintf (track_name, "%s", tag.title);

	else
		track_name = g_strconcat (tag.artist,
					  " - ",
					  tag.title,
					  NULL);
		//g_sprintf (track_name, "%s - %s", tag.artist, tag.title);
	
	gtk_list_store_append (list, &iter);
	gtk_list_store_set (list, &iter, COL_TRACK_NAME, track_name,
					 COL_LENGTH, tag.length,
					 COL_URI, uri,
					 COL_FILENAME, filename,
			    -1);

	num_tracks++;

	g_free (track_name);
}

// Gets the tag info and puts it into the list after a tag edit.
void reset_data (GtkWidget *treeview,
		 GtkListStore *list,
		 gchar *artist,
		 gchar *title)
{
	//GtkTreeIter iter;
	gchar *track_name;
	//GtkTreePath *path;
	//GtkTreeModel *model;

	//model = gtk_tree_view_get_model (GTK_TREE_VIEW (treeview));
	track_name = calloc (MAX_CHARS * 2, sizeof (gchar));

	if (g_strcmp0 (artist, "") == 0 && g_strcmp0 (title, "") != 0)
		track_name = g_strconcat ("Unknown Artist - ", title, NULL);
	else if (g_strcmp0 (title, "") == 0 && g_strcmp0 (artist, "") != 0)
		track_name = g_strconcat (artist, " - Unknown Title", NULL);
	else if (g_strcmp0 (artist, "") == 0 && g_strcmp0 (title, "") == 0)
		track_name = g_strconcat ("Unknown Artist - Unknown Title",
					  NULL);
	else
		track_name = g_strconcat (artist, " - ", title, NULL);

	//gtk_tree_view_get_cursor (GTK_TREE_VIEW (treeview), &path, NULL);
	//gtk_tree_model_get_iter (model, &iter, path);

	if (gtk_list_store_iter_is_valid (list, &editing))
		gtk_list_store_set (list, &editing,
				    COL_TRACK_NAME, track_name, -1);

	g_free (track_name);
}

// Clears the column of pixbufs so not more than one is set.
void clear_pixbuf (GtkListStore *list, GtkTreeView *treeview)
{
	GtkTreeModel *model;
	GtkTreeIter iter;

	model = gtk_tree_view_get_model (GTK_TREE_VIEW (treeview));

	if (gtk_tree_model_get_iter_first (model, &iter))
		gtk_list_store_set (list, &iter, COL_PLAYING, NULL, -1);
	else
		return;

	while (gtk_tree_model_iter_next (model, &iter))
		gtk_list_store_set (list, &iter, COL_PLAYING, NULL, -1);
}

// Parses tag information from a track, returns false if failed.
static gboolean parse_tag (gchar *filename, tag_info *track_tag)
{
	TagLib_File *open_file;
	TagLib_Tag *tag;
	const TagLib_AudioProperties *properties;
	gint min, sec;

	open_file = taglib_file_new (filename);

	if (open_file == NULL)
		return FALSE;

	tag = taglib_file_tag (open_file);
	properties = taglib_file_audioproperties (open_file);

	if (tag == NULL || properties == NULL)
		return FALSE;

	// If title or artist is just blank, set tag info to unknown.
	track_tag -> title = taglib_tag_title (tag);
	if (g_strcmp0 (track_tag -> title, "") == 0)
		track_tag -> title = "Unknown Title";

	track_tag -> artist = taglib_tag_artist (tag);
	if (g_strcmp0 (track_tag -> artist, "") == 0)
		track_tag -> artist = "Unknown Artist";

	// Grab all of the info and put it into the track tag information.
	track_tag -> album = taglib_tag_album (tag);
	track_tag -> year = taglib_tag_year (tag);
	track_tag -> comment = taglib_tag_comment (tag);
	track_tag -> track = taglib_tag_track (tag);
	track_tag -> genre = taglib_tag_genre (tag);
	track_tag -> bitrate = taglib_audioproperties_bitrate (properties);
	track_tag -> samplerate = taglib_audioproperties_samplerate
				  (properties);
	track_tag -> channels = taglib_audioproperties_channels (properties);

	sec = taglib_audioproperties_length (properties) % 60;
	min = (taglib_audioproperties_length (properties) - sec) / 60;

	g_sprintf (track_tag -> length, "%i:%02i", min, sec);

	taglib_file_free (open_file);

	return TRUE;
}

// Callback function for double clicking on a row.
void double_click_row (GtkTreeView *treeview, GtkTreePath *path,
                       GtkTreeViewColumn *col, gpointer data)
{
	GstElement *bin;
	GstState state;
	GtkListStore *pl_entries;
	GdkPixbuf *playing_icon;
	GtkTreeSelection *selection;
	GtkTreeModel *model;
	GtkTreeIter iter;
	GtkWidget *track_label;

	track_label = g_object_get_data (G_OBJECT (treeview), "track_label");
	playing_icon = g_object_get_data (G_OBJECT (treeview), "playing_icon");
	pl_entries = g_object_get_data (G_OBJECT (treeview), "pl_entries");
	bin = g_object_get_data (G_OBJECT (treeview), "bin");

	selection = gtk_tree_view_get_selection (GTK_TREE_VIEW (treeview));

	gst_element_set_state (bin, GST_STATE_NULL);
	gst_element_set_state (bin, GST_STATE_PLAYING);

	gst_element_get_state (bin, &state, NULL, GST_SECOND * 2);

	// If something is selected and playing, set the pixbuf to playing.
	if (gtk_tree_selection_get_selected (selection, &model, &iter)
	    && (g_strcmp0
	       (gst_element_state_get_name (state), "PLAYING") == 0))
	{
		gchar *label;

		clear_pixbuf (pl_entries, treeview);

		gtk_list_store_set (pl_entries,
				    &iter,
				    COL_PLAYING,
				    playing_icon,
				    -1);

		gtk_tree_model_get (model, &iter, 
				    COL_TRACK_NAME, &label, -1);

		gtk_label_set_text (GTK_LABEL (track_label), label);

		selected = iter;
		playing = gtk_tree_model_get_path (model, &iter);

		// For X Windows, sets the size of the window when video is played.
		#ifdef GDK_WINDOWING_X11
		GtkWidget *window;
		GList *stream_list;	// Stream info list.
		GObject *stream;	// Playing stream.
		GstObject *pad;		// The video pad.
		gint playing_video;	// Whether a video is playing.
		gint width = 0, height = 0;	// Width and height of video.

		window = g_object_get_data (G_OBJECT (treeview), "window");

		g_object_get (G_OBJECT (bin), "stream-info",
			      &stream_list, NULL);
		stream = g_list_nth_data (stream_list, 0);
		g_object_get (stream, "object", &pad, NULL);

		g_object_get (G_OBJECT (bin), "current-video",
			      &playing_video, NULL);

		if (playing_video > -1 &&
		    gst_video_get_size (GST_PAD (pad), &width, &height))
			gtk_window_resize (GTK_WINDOW (window),
					   width,
					   height + WIN_HEIGHT);
		else if (playing_video == -1)
			gtk_window_resize (GTK_WINDOW (window),
					   WIN_WIDTH,
					   WIN_HEIGHT);
		#endif
	}

}

// Callback to set the URI to the focused cell's file.
void focus_change (GtkTreeView *treeview, gpointer data)
{
	GtkTreeSelection *selection;
	GtkTreeModel *model;
	GtkTreeIter iter;
	GstElement *bin;

	bin = g_object_get_data (G_OBJECT (treeview), "bin");

	selection = gtk_tree_view_get_selection (GTK_TREE_VIEW (treeview));
	if (gtk_tree_selection_get_selected (selection, &model, &iter))
	{
		gchar *uri;

		// Get the URI value associated with the row element and set
		// the pipeline's selected track to that URI value.
		gtk_tree_model_get (model, &iter, COL_URI, &uri, -1);

		g_object_set (G_OBJECT (bin), "uri", uri, NULL);
		selected = iter;

		g_free (uri);
	}

}

// This callback function gets called every set amount of time to move the
// trackbar according to the track position.
static gboolean track_bar_callback (GstElement *pipeline)
{
	GtkWidget *seek_bar, *seek_label;

	seek_bar = g_object_get_data (G_OBJECT (pipeline), "seek_bar");
	seek_label = g_object_get_data (G_OBJECT (pipeline), "seek_label");

	GstFormat time = GST_FORMAT_TIME;
	gint64 cur_time, total_time;
	gdouble cur_time_float, total_time_float;

	// Query the position and set the seek bar to the percentage of the
	// track played.
	if (gst_element_query_position (pipeline, &time, &cur_time) &&
	    gst_element_query_duration (pipeline, &time, &total_time))
	{
		gchar *label_text;
	
		// This assumes time will never go over 32 characters.
		label_text = calloc (64, sizeof (gchar));

		g_sprintf (label_text,
			   "%02lld:%02lld:%02lld / %02lld:%02lld:%02lld",
			   (cur_time / 1000000000) / 3600,
			   ((cur_time / 1000000000) / 60) % 60,
			   (cur_time / 1000000000) % 60,
			   (total_time / 1000000000) / 3600,
			   ((total_time / 1000000000) / 60) % 60,
			   (total_time / 1000000000) % 60);


		cur_time_float = cur_time;
		total_time_float = total_time;

		// Set the seek bar and track time display to the current
		// position.
		g_signal_handlers_block_by_func (seek_bar, seek_changed, NULL);
		gtk_range_set_value (GTK_RANGE (seek_bar),
				     (cur_time_float / total_time_float) * 100);
		g_signal_handlers_unblock_by_func (seek_bar,
						   seek_changed,
						   NULL);
		gtk_label_set_text (GTK_LABEL (seek_label), label_text);
	}

  return TRUE;
}

// Changes the volume when the slider values have been changed for volume.
static void volume_changed (GtkWidget *widget, gpointer data)
{
	GstElement *bin;
	gdouble new_volume;

	bin = g_object_get_data (G_OBJECT (widget), "bin");
	bin = (GstElement *) bin;

	new_volume = gtk_range_get_value (GTK_RANGE (widget));
	g_object_set (G_OBJECT (bin), "volume", new_volume, NULL);	
}

// Changes the location of the track when the sliders have been dragged for the
// seek bar.
static void seek_changed (GtkWidget *widget, gpointer data)
{
	GtkWidget *window;
	GstElement *bin;
	gdouble percent, total_time_float;

	GstFormat time = GST_FORMAT_TIME;
	gint64 total_time;

	window = g_object_get_data (G_OBJECT (widget), "window");

	bin = g_object_get_data (G_OBJECT (widget), "bin");
	bin = (GstElement *) bin;

	percent = gtk_range_get_value (GTK_RANGE (widget));

	// Since we have the percentage, calculate the actual time that the
	// track is seeking to.
	if (gst_element_query_duration (bin, &time, &total_time))
	{
		total_time_float = total_time;

		percent = percent / 100;
		total_time_float = total_time_float * percent;
	}

	if (!gst_element_seek_simple (bin,
				      GST_FORMAT_TIME,
				      GST_SEEK_FLAG_FLUSH,
				      total_time_float))
		error_dialog (window, "Failed to Seek!");

	//printf ("Seek to: %f%s",
	//	  total_time_float / 1000000000, " seconds.\n");
}

// Called when a row is deleted from the list (needed before due to iter
// errors).
static void on_row_delete (GtkTreeModel *model,
			   GtkTreePath *path,
			   gpointer data)
{
	num_tracks--;

	/*GtkTreeIter temp;

	if (gtk_tree_model_get_iter_first (model, &temp))
	{
		// Set to previous path so that an iterator error isn't
		// generated.
		if (gtk_tree_path_compare (path, playing) == 0)
		{
			playing = NULL;
			//gtk_tree_path_prev (playing);
		}
	}*/
}

// Called when the program is closed to ensure video playback is stopped so an
// X Window error isn't thrown.
static void quit_program (GtkWidget *widget, gpointer data)
{
	GtkWidget *stop;

	stop = g_object_get_data (G_OBJECT (widget), "stop");

	gtk_button_clicked (GTK_BUTTON (stop));
	gtk_main_quit ();
}

// This function will be called when a user presses a button.
gboolean on_button_press (GtkWidget *treeview,
			  GdkEventButton *event,
			  gpointer data)
{
	// Enter here if there is something selected and a single right
	// click is pressed.
	if (event -> type == GDK_BUTTON_PRESS && event -> button == 3)
	{
		GtkTreeSelection *selection;

		selection = gtk_tree_view_get_selection
					(GTK_TREE_VIEW (treeview));

		//if (gtk_tree_selection_count_selected_rows (selection) != 0)
		//	playlist_popup (treeview, event, data);
		GtkTreePath *path;

		if (gtk_tree_view_get_path_at_pos (GTK_TREE_VIEW (treeview),
						   (gint) event -> x,
						   (gint) event -> y,
						   &path,
						   NULL, NULL, NULL))
		{
			gtk_tree_selection_select_path (selection, path);
			gtk_tree_view_set_cursor (GTK_TREE_VIEW (treeview),
						  path,
						  NULL,
						  FALSE);
			playlist_popup (treeview, event, data);
			gtk_tree_path_free (path);
		}

		return TRUE;
	}

	return FALSE;
}

// This is the right click context menu that will pop up when users right
// click on an item in the playlist.
static void playlist_popup (GtkWidget *treeview,
			    GdkEventButton *event,
			    gpointer data)
{
	GtkListStore *pl_entries;
	GtkWidget *pl_window;
	GtkWidget *play, *remove;
	GtkWidget *menu,
			*play_item,
			*remove_item,
			*tag_item;

	menu = gtk_menu_new();

	pl_window = g_object_get_data (G_OBJECT (treeview), "pl_window");
	pl_entries = g_object_get_data (G_OBJECT (treeview), "pl_entries");
	play = g_object_get_data (G_OBJECT (treeview), "play");
	remove = g_object_get_data (G_OBJECT (treeview), "remove");

	// Create the menu items.
	play_item = gtk_menu_item_new_with_label ("Play Selected Item");
	remove_item = gtk_menu_item_new_with_label ("Remove Selected Item");
	tag_item = gtk_menu_item_new_with_label ("Edit File Tag...");

	// Connect signal callbacks for menu items.
	g_object_set_data (G_OBJECT (play_item), "play", play);
	g_signal_connect (play_item,
			  "activate",
			  G_CALLBACK (menu_play),
			  NULL);

	g_object_set_data (G_OBJECT (remove_item), "remove", remove);
	g_signal_connect (remove_item,
			  "activate",
			  G_CALLBACK (menu_remove),
			  NULL);

	g_object_set_data (G_OBJECT (tag_item), "pl_window", pl_window);
	g_object_set_data (G_OBJECT (tag_item), "playlist", treeview);
	g_object_set_data (G_OBJECT (tag_item), "pl_entries", pl_entries);
	g_signal_connect (tag_item,
			  "activate",
			  G_CALLBACK (menu_tag),
			  NULL);

	// Add menu items to the menu and show the popup menu.
	gtk_menu_shell_append (GTK_MENU_SHELL (menu), play_item);
	gtk_menu_shell_append (GTK_MENU_SHELL (menu), remove_item);
	gtk_menu_shell_append (GTK_MENU_SHELL (menu), tag_item);

	gtk_widget_show_all (menu);

	gtk_menu_popup (GTK_MENU (menu), NULL, NULL, NULL, NULL,
			(event != NULL) ? event -> button : 0,
			event -> time);
}

// Playlist context menu play.
static void menu_play (GtkWidget *widget, gpointer data)
{
	GtkWidget *play;

	play = g_object_get_data (G_OBJECT (widget), "play");

	gtk_button_clicked (GTK_BUTTON (play));
}

// Playlist context menu remove.
static void menu_remove (GtkWidget *widget, gpointer data)
{
	GtkWidget *remove;

	remove = g_object_get_data (G_OBJECT (widget), "remove");

	gtk_button_clicked (GTK_BUTTON (remove));
}

// Playlist context menu edit tag.
static void menu_tag (GtkWidget *widget, gpointer data)
{
	GtkTreeSelection *selection;
	GtkTreeIter iter;
	GtkTreeModel *model;
	GtkWidget *playlist, *pl_window;
	GtkListStore *pl_entries;
	GdkPixbuf *window_icon;

	window_icon = gdk_pixbuf_new_from_file ("./img/icon.png", NULL);

	pl_window = g_object_get_data (G_OBJECT (widget), "pl_window");
	playlist = g_object_get_data (G_OBJECT (widget), "playlist");
	pl_entries = g_object_get_data (G_OBJECT (widget), "pl_entries");

	model = gtk_tree_view_get_model (GTK_TREE_VIEW (playlist));

	selection = gtk_tree_view_get_selection (GTK_TREE_VIEW (playlist));
	if (gtk_tree_selection_get_selected (selection, &model, &iter))
	{
		gchar *filename;
		TagLib_File *open_file;
		TagLib_Tag *tag;
		const TagLib_AudioProperties *properties;

		// Get the filename associated with the row element.
		gtk_tree_model_get (model, &iter, COL_FILENAME, &filename, -1);

		open_file = taglib_file_new (filename);

		if (open_file == NULL)
		{
			error_dialog (pl_window, "Error reading file tag.");
			return;
		}

		tag = taglib_file_tag (open_file);
		properties = taglib_file_audioproperties (open_file);

		if (tag == NULL || properties == NULL)
		{
			error_dialog (pl_window, "File does not have a valid tag.");
			return;
		}
		
		// Tag dialog box starts here.
		GtkWidget *tag_window;		// Window for the tag dialog.
		GtkWidget *f_metadata, *f_properties;	// Frames.
		GtkWidget *vbox_main,		// Vertical boxes.
			  *vbox_labels,
			  *vbox_entries,
			  *vbox_properties;
		GtkWidget *hbox_main,		// Horizontal boxes.
			  *hbox_buttons;
		GtkWidget *metatable;		// Table for the metadata.
		GtkWidget *save, *cancel;	// Buttons.

		GtkWidget *track_l, *year_l,	// Labels next to textviews.
			  *title_l,
			  *artist_l,
			  *album_l,
			  *genre_l,
			  *comment_l;

		GtkWidget *filename_t,
			  *track_t, *year_t,	// Entry boxes.
			  *title_t,
			  *artist_t,
			  *album_t,
			  *genre_t,
			  *comment_t;		// Comment text view.
		GtkTextBuffer *comment_b;	// Comment text buffer.

		GtkWidget *bitrate,		// Audio information labels.
			  *samplerate,
			  *channels,
			  *length;
		
		gchar *temp;
		temp = calloc (4096, sizeof (gchar));

		editing = selected;

		// Create all of the containers and set their properties.
		tag_window = gtk_window_new (GTK_WINDOW_TOPLEVEL);

		gtk_widget_set_size_request (tag_window, 640, 375);
		gtk_window_set_resizable (GTK_WINDOW (tag_window), FALSE);
		gtk_window_set_icon (GTK_WINDOW (tag_window), window_icon);
		gtk_window_set_transient_for (GTK_WINDOW (tag_window),
					      GTK_WINDOW (pl_window));
		gtk_window_set_modal (GTK_WINDOW (tag_window), TRUE);

		f_metadata = gtk_frame_new ("Metadata");
		gtk_widget_set_size_request (f_metadata, 440, 300);

		f_properties = gtk_frame_new ("Audio Properties");
		gtk_widget_set_size_request (f_properties, 200, 300);

		vbox_main = gtk_vbox_new (FALSE, 0);
		gtk_container_set_border_width (GTK_CONTAINER (vbox_main), 5);
		vbox_labels = gtk_vbox_new (FALSE, 0);
		vbox_entries = gtk_vbox_new (FALSE, 0);
		vbox_properties = gtk_vbox_new (FALSE, 0);
		gtk_container_set_border_width
					(GTK_CONTAINER (vbox_properties), 5);
		hbox_main = gtk_hbox_new (FALSE, 0);
		hbox_buttons = gtk_hbox_new (FALSE, 0);

		metatable = gtk_table_new (8, 4, FALSE);
		gtk_container_set_border_width (GTK_CONTAINER (metatable), 5);

		// Create buttons.
		save = gtk_button_new_with_label ("Save");
		cancel = gtk_button_new_with_label ("Cancel");

		// Start creation of labels and setting their properties.
		track_l = gtk_label_new ("Track #");
		gtk_misc_set_alignment (GTK_MISC (track_l), 1, 0.5);

		year_l = gtk_label_new ("Year");
		gtk_misc_set_alignment (GTK_MISC (year_l), 1, 0.5);

		title_l = gtk_label_new ("Title");
		gtk_misc_set_alignment (GTK_MISC (title_l), 1, 0.5);

		artist_l = gtk_label_new ("Artist");
		gtk_misc_set_alignment (GTK_MISC (artist_l), 1, 0.5);

		album_l = gtk_label_new ("Album");
		gtk_misc_set_alignment (GTK_MISC (album_l), 1, 0.5);

		genre_l = gtk_label_new ("Genre");
		gtk_misc_set_alignment (GTK_MISC (genre_l), 1, 0.5);

		comment_l = gtk_label_new ("Comment");
		gtk_misc_set_alignment (GTK_MISC (comment_l), 1, 0);

		// Start filling audio properties data.
		bitrate = gtk_label_new ("Bitrate: ");
		gtk_misc_set_alignment (GTK_MISC (bitrate), 0, 0.5);
		gtk_misc_set_padding (GTK_MISC (bitrate), 2, 0);
		g_sprintf (temp, "Bitrate: %i kbps",
			   taglib_audioproperties_bitrate (properties));
		gtk_label_set_text (GTK_LABEL (bitrate), temp);

		samplerate = gtk_label_new ("Sample Rate: ");
		gtk_misc_set_alignment (GTK_MISC (samplerate), 0, 0.5);
		gtk_misc_set_padding (GTK_MISC (samplerate), 2, 0);
		g_sprintf (temp, "Sample Rate: %i kHz",
			   taglib_audioproperties_samplerate (properties));
		gtk_label_set_text (GTK_LABEL (samplerate), temp);

		channels = gtk_label_new ("Channels: ");
		gtk_misc_set_alignment (GTK_MISC (channels), 0, 0.5);
		gtk_misc_set_padding (GTK_MISC (channels), 2, 0);
		g_sprintf (temp, "Channels: %i",
			   taglib_audioproperties_channels (properties));
		gtk_label_set_text (GTK_LABEL (channels), temp);

		length = gtk_label_new ("Length: ");
		gtk_misc_set_alignment (GTK_MISC (length), 0, 0.5);
		gtk_misc_set_padding (GTK_MISC (length), 2, 0);
		g_sprintf (temp, "Length: %i seconds",
			   taglib_audioproperties_length (properties));
		gtk_label_set_text (GTK_LABEL (length), temp);

		// Create the text entries and fill them with tag data.
		filename_t = gtk_entry_new ();
		gtk_entry_set_editable (GTK_ENTRY (filename_t), FALSE);
		gtk_entry_set_text (GTK_ENTRY (filename_t), filename);
		
		track_t = gtk_entry_new ();
		gtk_widget_set_size_request (track_t, 50, -1);
		if (taglib_tag_track (tag) != 0)
		{
			g_sprintf (temp, "%i", taglib_tag_track (tag));
			gtk_entry_set_text (GTK_ENTRY (track_t), temp);
		}

		year_t = gtk_entry_new ();
		gtk_widget_set_size_request (year_t, 50, -1);
		g_sprintf (temp, "%i", taglib_tag_year (tag));
		if (taglib_tag_track (tag) != 0)
		{
			g_sprintf (temp, "%i", taglib_tag_track (tag));
			gtk_entry_set_text (GTK_ENTRY (year_t), temp);
		}

		title_t = gtk_entry_new ();
		gtk_widget_set_size_request (title_t, 300, -1);
		gtk_entry_set_max_length (GTK_ENTRY (title_t), MAX_CHARS);
		temp = taglib_tag_title (tag);
		gtk_entry_set_text (GTK_ENTRY (title_t), temp);

		artist_t = gtk_entry_new ();
		gtk_widget_set_size_request (artist_t, 300, -1);
		gtk_entry_set_max_length (GTK_ENTRY (artist_t), MAX_CHARS);
		temp = taglib_tag_artist (tag);
		gtk_entry_set_text (GTK_ENTRY (artist_t), temp);

		album_t = gtk_entry_new ();
		gtk_widget_set_size_request (album_t, 300, -1);
		gtk_entry_set_max_length (GTK_ENTRY (album_t), MAX_CHARS);
		temp = taglib_tag_album (tag);
		gtk_entry_set_text (GTK_ENTRY (album_t), temp);

		genre_t = gtk_entry_new ();
		gtk_widget_set_size_request (genre_t, 300, -1);
		gtk_entry_set_max_length (GTK_ENTRY (genre_t), MAX_CHARS);
		temp = taglib_tag_genre (tag);
		gtk_entry_set_text (GTK_ENTRY (genre_t), temp);

		comment_t = gtk_text_view_new ();
		gtk_widget_set_size_request (comment_t, 300, 80);
		gtk_text_view_set_wrap_mode (GTK_TEXT_VIEW (comment_t),
					     GTK_WRAP_WORD);
		comment_b = gtk_text_view_get_buffer
					(GTK_TEXT_VIEW (comment_t));
		temp = taglib_tag_comment (tag);
		gtk_text_buffer_set_text (comment_b, temp, -1);

		// Pack all of the widgets into their containers.
		gtk_container_add (GTK_CONTAINER (tag_window), vbox_main);
		gtk_box_pack_start (GTK_BOX (vbox_main),
				    filename_t, FALSE, FALSE, 2);
		gtk_box_pack_start (GTK_BOX (vbox_main),
				    hbox_main, FALSE, FALSE, 2);
		gtk_box_pack_start (GTK_BOX (vbox_main),
				    hbox_buttons, FALSE, FALSE, 2);
		gtk_box_pack_start (GTK_BOX (hbox_main),
				    f_metadata, TRUE, TRUE, 2);
		gtk_box_pack_start (GTK_BOX (hbox_main),
				    f_properties, FALSE, FALSE, 2);

		gtk_container_add (GTK_CONTAINER (f_metadata), metatable);
		gtk_table_attach (GTK_TABLE (metatable), track_l,
				  0, 1, 0, 1, GTK_FILL, GTK_FILL, 2, 2);
		gtk_table_attach (GTK_TABLE (metatable), track_t,
				  1, 2, 0, 1, GTK_FILL, GTK_FILL, 2, 2);
		gtk_table_attach (GTK_TABLE (metatable), year_l,
				  2, 3, 0, 1, GTK_FILL, GTK_FILL, 2, 2);
		gtk_table_attach (GTK_TABLE (metatable), year_t,
				  3, 4, 0, 1, GTK_FILL, GTK_FILL, 2, 2);
		gtk_table_attach (GTK_TABLE (metatable), title_l,
				  0, 1, 1, 2, GTK_FILL, GTK_FILL, 2, 2);
		gtk_table_attach (GTK_TABLE (metatable), title_t,
				  1, 4, 1, 2, GTK_FILL, GTK_FILL, 2, 2);
		gtk_table_attach (GTK_TABLE (metatable), artist_l,
				  0, 1, 2, 3, GTK_FILL, GTK_FILL, 2, 2);
		gtk_table_attach (GTK_TABLE (metatable), artist_t,
				  1, 4, 2, 3, GTK_FILL, GTK_FILL, 2, 2);
		gtk_table_attach (GTK_TABLE (metatable), album_l,
				  0, 1, 3, 4, GTK_FILL, GTK_FILL, 2, 2);
		gtk_table_attach (GTK_TABLE (metatable), album_t,
				  1, 4, 3, 4, GTK_FILL, GTK_FILL, 2, 2);
		gtk_table_attach (GTK_TABLE (metatable), genre_l,
				  0, 1, 4, 5, GTK_FILL, GTK_FILL, 2, 2);
		gtk_table_attach (GTK_TABLE (metatable), genre_t,
				  1, 4, 4, 5, GTK_FILL, GTK_FILL, 2, 2);
		gtk_table_attach (GTK_TABLE (metatable), comment_l,
				  0, 1, 5, 7, GTK_FILL, GTK_FILL, 2, 2);
		gtk_table_attach (GTK_TABLE (metatable), comment_t,
				  1, 4, 5, 7, GTK_FILL, GTK_FILL, 2, 2);

		gtk_container_add (GTK_CONTAINER (f_properties), vbox_properties);
		gtk_box_pack_start (GTK_BOX (vbox_properties),
				    bitrate, FALSE, FALSE, 0);
		gtk_box_pack_start (GTK_BOX (vbox_properties),
				    samplerate, FALSE, FALSE, 0);
		gtk_box_pack_start (GTK_BOX (vbox_properties),
				    channels, FALSE, FALSE, 0);
		gtk_box_pack_start (GTK_BOX (vbox_properties),
				    length, FALSE, FALSE, 0);

		gtk_box_pack_end (GTK_BOX (hbox_buttons),
				    cancel, FALSE, FALSE, 2);
		gtk_box_pack_end (GTK_BOX (hbox_buttons),
				    save, FALSE, FALSE, 2);

		// Connect signals for the buttons to their callback.
		g_object_set_data (G_OBJECT (save),
				   "tag_window", tag_window);
		g_object_set_data (G_OBJECT (save), "playlist", playlist);
		g_object_set_data (G_OBJECT (save), "pl_entries", pl_entries);
		g_object_set_data (G_OBJECT (save), "open_file", open_file);
		g_object_set_data (G_OBJECT (save), "track_t", track_t);
		g_object_set_data (G_OBJECT (save), "year_t", year_t);
		g_object_set_data (G_OBJECT (save), "title_t", title_t);
		g_object_set_data (G_OBJECT (save), "artist_t", artist_t);
		g_object_set_data (G_OBJECT (save), "album_t", album_t);
		g_object_set_data (G_OBJECT (save), "genre_t", genre_t);
		g_object_set_data (G_OBJECT (save), "comment_b", comment_b);
		g_signal_connect (G_OBJECT (save), "clicked",
				  G_CALLBACK (save_button_clicked), NULL);
		g_object_set_data (G_OBJECT (cancel),
				   "tag_window", tag_window);
		g_object_set_data (G_OBJECT (cancel), "open_file", open_file);
		g_signal_connect (G_OBJECT (cancel), "clicked",
				  G_CALLBACK (cancel_button_clicked), NULL);

		gtk_widget_show_all (tag_window);

		g_free (filename);
		g_free (temp);
	}
}

// Saves the file tags when the save button is clicked.
static void save_button_clicked (GtkWidget *widget, gpointer data)
{
	GtkWidget *track_t,
		  *year_t,
		  *title_t,
		  *artist_t,
		  *album_t,
		  *genre_t,
		  *tag_window,
		  *playlist;
	GtkListStore *pl_entries;
	GtkTextBuffer *comment_b;
	tag_info track_info;
	GtkTextIter comment_start, comment_end;
	TagLib_File *open_file;
	TagLib_Tag *tag;

	tag_window = g_object_get_data (G_OBJECT (widget), "tag_window");
	playlist = g_object_get_data (G_OBJECT (widget), "playlist");
	pl_entries = g_object_get_data (G_OBJECT (widget), "pl_entries");
	open_file = g_object_get_data (G_OBJECT (widget), "open_file");
	track_t = g_object_get_data (G_OBJECT (widget), "track_t");
	year_t = g_object_get_data (G_OBJECT (widget), "year_t");
	title_t = g_object_get_data (G_OBJECT (widget), "title_t");
	artist_t = g_object_get_data (G_OBJECT (widget), "artist_t");
	album_t = g_object_get_data (G_OBJECT (widget), "album_t");
	genre_t = g_object_get_data (G_OBJECT (widget), "genre_t");
	comment_b = g_object_get_data (G_OBJECT (widget), "comment_b");

	tag = taglib_file_tag (open_file);

	if (tag == NULL)
		return;

	// Initialize all of the variables.
	gtk_text_buffer_get_start_iter (comment_b, &comment_start);
	gtk_text_buffer_get_end_iter (comment_b, &comment_end);
	track_info.title = calloc (MAX_CHARS, sizeof (gchar));
	track_info.artist = calloc (MAX_CHARS, sizeof (gchar));
	track_info.album = calloc (MAX_CHARS, sizeof (gchar));
	track_info.genre = calloc (MAX_CHARS, sizeof (gchar));

	// Set all the necessary info.
	track_info.track =
	(int) g_ascii_strtoll (gtk_entry_get_text (GTK_ENTRY (track_t)),
				       NULL, 10);
	track_info.year =
	(int) g_ascii_strtoll (gtk_entry_get_text (GTK_ENTRY (year_t)),
				       NULL, 10);
	g_sprintf (track_info.title, "%s",
		   gtk_entry_get_text (GTK_ENTRY (title_t)));
	g_sprintf (track_info.artist, "%s",
		   gtk_entry_get_text (GTK_ENTRY (artist_t)));
	g_sprintf (track_info.album, "%s",
		   gtk_entry_get_text (GTK_ENTRY (album_t)));
	g_sprintf (track_info.genre, "%s",
		   gtk_entry_get_text (GTK_ENTRY (genre_t)));
	track_info.comment =
	gtk_text_buffer_get_text (comment_b,
				  &comment_start,
				  &comment_end,
				  FALSE);

	taglib_tag_set_track (tag, track_info.track);
	taglib_tag_set_year (tag, track_info.year);
	taglib_tag_set_title (tag, track_info.title);
	taglib_tag_set_artist (tag, track_info.artist);
	taglib_tag_set_album (tag, track_info.album);
	taglib_tag_set_genre (tag, track_info.genre);
	taglib_tag_set_comment (tag, track_info.comment);

	taglib_file_save (open_file);

	reset_data (playlist, pl_entries, track_info.artist, track_info.title);

	gtk_widget_destroy (tag_window);

	// Free the memory.
	g_free (track_info.title);
	g_free (track_info.artist);
	g_free (track_info.album);
	g_free (track_info.genre);
	taglib_file_free (open_file);
}

// If cancel is clicked while editing tag, just hide the window.
static void cancel_button_clicked (GtkWidget *widget, gpointer data)
{
	GtkWidget *tag_window;
	TagLib_File *open_file;

	tag_window = g_object_get_data (G_OBJECT (widget), "tag_window");
	open_file = g_object_get_data (G_OBJECT (widget), "open_file");

	taglib_file_free (open_file);
	gtk_widget_destroy (tag_window);
}

// Code specific to environments using the X Window System.
#ifdef GDK_WINDOWING_X11
// Most of this code from the next two functions have been adapted from the
// gstreamer documentation.

// Tells the application to render video to an existing window.
static GstBusSyncReply bus_sync (GstBus *bus,
				 GstMessage *message,
				 gpointer data)
{
	// Watch the bus for "prepare-xwindow-id" messages.
	if (GST_MESSAGE_TYPE (message) != GST_MESSAGE_ELEMENT)
		return GST_BUS_PASS;
	if (!gst_structure_has_name (message -> structure,
				     "prepare-xwindow-id"))
		return GST_BUS_PASS;

	// Assign the xvindow id to the video sink.
	if (video_window_xid != 0)
	{
		//GstXOverlay *xoverlay;
		GstElement *video_sink;
		video_sink = g_object_get_data (G_OBJECT (bus), "video_sink");
		// Grab the video sink and set the XID of the window.
		//xoverlay = GST_X_OVERLAY (GST_MESSAGE_SRC (message));
		//gst_x_overlay_set_xwindow_id (xoverlay, video_window_xid);
		gst_x_overlay_set_xwindow_id (GST_X_OVERLAY (video_sink),
					      video_window_xid);
	}
	else
		g_warning ("Still haven't obtained window XID...");
	
	gst_message_unref (message);
	return GST_BUS_DROP;	
}

// Called to set resources ahead of time for the video window so we can get
// the XID of the video window.
static void video_realized (GtkWidget *widget, gpointer data)
{
	#if GTK_CHECK_VERSION (2, 18, 0)
		if (!gdk_window_ensure_native (widget -> window))
			g_error ("Could not create native window...");
	#endif
	video_window_xid = GDK_WINDOW_XID (widget -> window);
}

gboolean catch_video_button (GtkWidget *widget,
			     GdkEventButton *event,
			     gpointer data)
{
	if (event -> type == GDK_2BUTTON_PRESS)
	{
		GtkWidget *window,
			  *hbox_seek,
			  *hbox_buttons,
			  *track_label,
			  *open_pl;

		window = g_object_get_data (G_OBJECT (widget), "window");
		hbox_seek = g_object_get_data (G_OBJECT (widget), "hbox_seek");
		hbox_buttons = g_object_get_data (G_OBJECT (widget),
						  "hbox_buttons");
		track_label = g_object_get_data (G_OBJECT (widget),
						 "track_label");
		open_pl = g_object_get_data (G_OBJECT (window), "open_pl");

		// If the window is in it's normal state, set it to FULLSCREEN.
		if (window_state == 4 || window_state == 0)
		{
			gtk_window_fullscreen (GTK_WINDOW (window));

			gtk_widget_hide (hbox_seek);
			gtk_widget_hide (hbox_buttons);
			gtk_widget_hide (track_label);

			gtk_widget_set_sensitive (open_pl, FALSE);
		}
		// If it's FULLSCREEN and MAXIMIZED or just FULLSCREEN'ed,
		// revert it back.
		else if (window_state == 16 || window_state == 20)
		{
			gtk_window_unfullscreen (GTK_WINDOW (window));

			gtk_widget_show (hbox_seek);
			gtk_widget_show (hbox_buttons);
			gtk_widget_show (track_label);

			gtk_widget_set_sensitive (open_pl, TRUE);
		}

		return TRUE;
	}

	return FALSE;
}

// Catches Alt+Enter.
gboolean catch_window_key (GtkWidget *window,
			   GdkEventKey *event,
			   gpointer data)
{
	guint modifier;

	modifier = gtk_accelerator_get_default_mod_mask ();

	if (event -> keyval == GDK_Return
	    && (event -> state & modifier) == GDK_MOD1_MASK)
	{
		GtkWidget *hbox_seek, *hbox_buttons, *track_label, *open_pl;

		hbox_seek = g_object_get_data (G_OBJECT (window), "hbox_seek");
		hbox_buttons = g_object_get_data (G_OBJECT (window),
						  "hbox_buttons");
		track_label = g_object_get_data (G_OBJECT (window),
						 "track_label");
		open_pl = g_object_get_data (G_OBJECT (window), "open_pl");

		// If the window is in it's normal state, set it to FULLSCREEN.
		if (window_state == 4 || window_state == 0)
		{
			gtk_window_fullscreen (GTK_WINDOW (window));

			gtk_widget_hide (hbox_seek);
			gtk_widget_hide (hbox_buttons);
			gtk_widget_hide (track_label);

			gtk_widget_set_sensitive (open_pl, FALSE);
		}
		// If it's FULLSCREEN and MAXIMIZED or just FULLSCREEN'ed,
		// revert it back.
		else if (window_state == 16 || window_state == 20)
		{
			gtk_window_unfullscreen (GTK_WINDOW (window));

			gtk_widget_show (hbox_seek);
			gtk_widget_show (hbox_buttons);
			gtk_widget_show (track_label);

			gtk_widget_set_sensitive (open_pl, TRUE);
		}

		return TRUE;
	}

	else if (event -> keyval == GDK_space)
	{
		GtkWidget *pause;
		pause = g_object_get_data (G_OBJECT (window), "pause");

		gtk_button_clicked (GTK_BUTTON (pause));

		return TRUE;
	}

	return FALSE;
}

// Gets the current window state.
gboolean window_fullscreen (GtkWidget *widget,
			    GdkEventWindowState *event,
			    gpointer data)
{
	window_state = event -> new_window_state;

	return FALSE;
}

// Shows the widgets on the bottom of the screen if user's cursor is on the
// bottom of the screen. Hides them otherwise.
gboolean window_motion (GtkWidget *widget,
			    GdkEventMotion *event,
			    gpointer data)
{
/*
	GdkScreen *screen;
	GtkWidget *hbox_seek, *hbox_buttons, *track_label;
	gint x_resolution, y_resolution;

	screen = gdk_screen_get_default ();
	hbox_seek = g_object_get_data (G_OBJECT (widget), "hbox_seek");
	hbox_buttons = g_object_get_data (G_OBJECT (widget),
					  "hbox_buttons");
	track_label = g_object_get_data (G_OBJECT (widget),
					 "track_label");

	if (screen == NULL)
		return FALSE;

	x_resolution = gdk_screen_get_width (screen);
	y_resolution = gdk_screen_get_height (screen);

	// Show widgets if mouse is on the bottom of the screen during full-
	// screen mode.
	if (window_state == 16 || window_state == 20)
	{
		if (event -> y < y_resolution &&
		    event -> y > y_resolution - 150)
		{
			gtk_widget_show (hbox_seek);
			gtk_widget_show (hbox_buttons);
			gtk_widget_show (track_label);

			return FALSE;
		}

		else if (event -> y < y_resolution - 150
			 && event -> y >= 0)
		{
			gtk_widget_hide (hbox_seek);
			gtk_widget_hide (hbox_buttons);
			gtk_widget_hide (track_label);

			return FALSE;
		}
	}
*/
	return FALSE;
}
#endif
