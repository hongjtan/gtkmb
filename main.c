/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\
* TITLE: GTK Media Box                                                        *
* AUTHOR: Hong Tan                                                            *
* DATE: April 5, 2010                                                         *
* MODIFIED: May 20, 2010                                                      *
* VERSION: 0.0.5                                                              *
*                                                                             *
* This program is designed to play media files using an autoplugger method,   *
* which chooses the best decoder given a stream. Has the functions of a	      *
* standard media player and uses gstreamer codecs. Functions better when using*
* the X Window System.                                                        *
*                                                                             *
* LICENSE:                                                                    *
* Copyright (C) 2010, 2013 Hong Jie Tan                                       *
*                                                                             *
* This file is part of GTKMB.                                                 *
*                                                                             *
*   GTKMB is free software: you can redistribute it and/or modify             *
*   it under the terms of the GNU General Public License as published by      *
*   the Free Software Foundation, either version 3 of the License, or         *
*   (at your option) any later version.                                       *
*                                                                             *
*   GTKMB is distributed in the hope that it will be useful,                  *
*   but WITHOUT ANY WARRANTY; without even the implied warranty of            *
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             *
*   GNU General Public License for more details.                              *
*                                                                             *
*   You should have received a copy of the GNU General Public License         *
*   along with GTKMB.  If not, see <http://www.gnu.org/licenses/>.            *
*                                                                             *
* INSTALL FROM PACKAGE MANAGER:                                               *
*	- GTK 2.18+ and all required libraries.                                   *
*	- gstreamer development libraries, plugins, codecs for whichever          *
*	  files you want to play, etc. [base plugin development libraries         *
*	  need to be installed as well.]                                          *
*	  (gstreamer0.10, libgstreamer-plugins-base0.10-0-dev)                    *
*	- Taglib C Bindings development libraries.                                *
*	  (libtagc0-dev)                                                          *
*	- GnomeVFS 2.0 development libraries.                                     *
*	  (libgnomevfs2-dev)                                                      *
*	- libtotem-plparser-dev-2.28 required for UNIX systems. In order to       *
*	  compile on 2.28, uncomment 2.28 code in save_pl_button_clicked and      *
*	  comment out 2.30 code and vice versa for changing back.                 *
*	- Of course, all corresponding runtime libraries need to be installed     *
*	  as well.                                                                *
*                                                                             *
* TO DO: (I = Incomplete, C = Complete, P = Partially Fixed)                  *
*	C [HIGH] Put video window in a window that I create myself to catch       *
*		 button presses. [Decided to compromise, environments not             *
*		 using the X Window System will get an automatic window               *
*		 window generated by gstreamer, not catching button presses,          *
*		 therefore, the application will run better on environments           *
*		 which do use it.]                                                    *
*	C [HIGH] Add to playlist is currently opening files instead of adding     *
*	         to playlist for testing purposes.                                *
*	C [HIGH] Add a playlist using tree view that switches to the next song    *
*		 as soon as playback for one is done.                                 *
*	C [HIGH] strrchr in add_button_clicked is crashing in Windows but is      *
*		 fine on Linux.                                                       *
*	C [MEDIUM] Seek bar.                                                      *
*	C [MEDIUM] Volume bar.                                                    *
*	C [MEDIUM] Catch button presses in the video screen.                      *
*	C [LOW] Monitoring the program in process manager shows a minor memory    *
*		Leak if you repeatedly grab file info.                                *
*	C [LOW] Constrain proportions of the video when in full screen, so        *
*		image doesn't look stretched.                                         *
*		[Fixed by putting my own video sink inside the playbin and            *
*		setting the force-aspect-ratio property.]                             *
*	C [LOW] Need to clear the drawing area after videos are stopped or        *
*		window size is changed.                                               *
*                                                                             *
*	C [HIGH] Split the code into separate files.                              *
*	I [MEDIUM] Shuffle at the moment is with replacement and loops.           *
*	I [LOW] Filter so you can only open supported file formats.               *
*	P [LOW] Add loop and shuffle buttons that go back to the first element    *
*		of the tree view after it is done playing or generate a random        *
*		track number to play, respectively.                                   *
*	I [LOW] Re-open the last playlist that was open before the program        *
*		last closed.                                                          *
*	I [LOW] Setting a pause icon in the playlist did not work correctly,      *
*		and has therefore been set aside.                                     *
*	P [LOW] There are some iterator problems, but I can't reproduce them.     *
*		[Most of these have been fixed, I haven't been able to produce        *
*		any new iterator warnings or errors.]                                 *
*                                                                             *
*	[NOTE] Sometimes upon first playing a file will lag. Not sure if it's     *
*	       a gstreamer problem or something in the code.                      *
*	       [Seems to happen on slower systems, such as a virtual system.]     *
*	[NOTE] Taglib only tags select audio files, and no video files.           *
*	[NOTE] Code is pretty unorganized and messy since I didn't do any         *
*	       cleanup or split files yet.                                        *
*                                                                             *
\* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

#include <gtk/gtk.h>
#include <glib.h>
#include <gst/gst.h>
#include <gdk-pixbuf/gdk-pixbuf.h>
#include "playlist.h"
#include "player.h"
#include "video.h"
#include "variables.h"
#include "res.h"

#ifdef GDK_WINDOWING_X11
	#include <gdk/gdkx.h>
	#include <gdk/gdkkeysyms.h>
	#include <gst/interfaces/xoverlay.h>
	#include <gst/video/video.h>
#endif

gulong video_window_xid;
GtkTreePath *playing;

int main (int argc, char *argv[])
{	
	GtkWidget *window,	// The main window of the program.
		  *pl_window,	// The window for the playlist.
		  *vbox,	// The vertical box which holds hbox.
		  *hbox_seek,	// Holds the seek bar and time display.
		  *hbox_buttons,// Holds the buttons of the player.
		  *vbox_pl,	// Vertical box for the playlist.
		  *hbox_pl;	// Holds the buttons for the playlist.
	GtkWidget *back, *play, *pause, *stop, *next, *add, *remove, *open_pl,
		  *new_pl, *load_pl, *save_pl, *separate, *loop, *shuffle, *help;
	GtkWidget *back_icon,	// Icons representing each of the buttons on
		  *play_icon,	// player.
		  *pause_icon,
		  *stop_icon,
		  *next_icon,
		  *add_icon,
		  *remove_icon,
		  *open_pl_icon,
		  *new_pl_icon,
		  *load_pl_icon,
		  *save_pl_icon,
		  *loop_icon,
		  *shuffle_icon,
		  *help_icon;
	GtkWidget *scroll_pl;	// Scroll window for the playlist.
	GtkWidget *playlist;	// Used for the playlist.
	GtkWidget *volume_bar,	// Volume scale.
		  *seek_bar,	// Seek scale.
		  *seek_label,	// Seek time display.
		  *track_label;	// Track artist and title display.
	GtkObject *seek_adjust,	// Holds adjustments for the seek and volume
		  *vol_adjust;	// control.
	GtkListStore *pl_entries;	// Used to hold the playlist entries.
	GdkPixbuf *window_icon,	// The window's icon.
		  *playing_icon,// The play indicator icon.
		  *paused_icon;	// The paused indicator icon.
	GtkWidget *volume_icon; // Volume icon.
	GstElement *bin,	// A playbin to decode, demux, etc. audio/video
		   *video_sink;	// files and a video sink to set properties.
	GstBus *bus;		// A bus that grabs messages from the playbin
				// pipeline.
	gdouble volume;		// Holds the starting volume of the playbin.
	guint timeout_id;	// Holds the ID for the timeout function. 
	GtkTreeSelection *selection;

	gst_init (&argc, &argv);
	gtk_init (&argc, &argv);

	#ifdef GDK_WINDOWING_X11
	// Code adapted from gstreamer documentation.
	GtkWidget *video;

	video = gtk_drawing_area_new ();
	gtk_widget_set_events (video, GDK_BUTTON_PRESS_MASK |
				      GDK_KEY_PRESS_MASK);
	g_signal_connect (video, "realize",
			  G_CALLBACK (video_realized), NULL);
	g_signal_connect (video, "button-press-event",
			  G_CALLBACK (catch_video_button), NULL);
	#endif

	// Create labels to display time and track artist/title.
	seek_label = gtk_label_new ("--:--:-- / --:--:--");
	gtk_label_set_single_line_mode (GTK_LABEL (seek_label), TRUE);
	track_label = gtk_label_new ("No Track Selected");
	gtk_label_set_single_line_mode (GTK_LABEL (track_label), TRUE);
	gtk_misc_set_alignment (GTK_MISC (track_label), 0, 0.5);
	gtk_misc_set_padding (GTK_MISC (track_label), 5, 5);

	// Create the window and set its properties.
	window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
	//window_icon = gdk_pixbuf_new_from_file ("./img/icon.png", NULL);
	window_icon = gdk_pixbuf_new_from_inline (-1, icon_img, FALSE, NULL);
	gtk_widget_set_size_request (window, WIN_WIDTH, WIN_HEIGHT);
	gtk_window_set_title (GTK_WINDOW (window), "GTK Media Box");
	gtk_window_set_resizable (GTK_WINDOW (window), TRUE);
	gtk_window_set_icon (GTK_WINDOW (window), window_icon);

	pl_window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
	gtk_window_set_title (GTK_WINDOW (pl_window), "Playlist");
	gtk_widget_set_size_request (pl_window, 410, 200);
	gtk_window_set_resizable (GTK_WINDOW (pl_window), TRUE);
	gtk_window_set_icon (GTK_WINDOW (pl_window), window_icon);
	gtk_window_set_destroy_with_parent (GTK_WINDOW (pl_window), TRUE);
	gtk_window_set_position (GTK_WINDOW (pl_window), GTK_WIN_POS_CENTER);

	// Create the frames on the player.
	vbox = gtk_vbox_new (FALSE, 5);
	hbox_seek = gtk_hbox_new (FALSE, 5);
	hbox_buttons = gtk_hbox_new (FALSE, 5);
	vbox_pl = gtk_vbox_new (FALSE, 5);
	hbox_pl = gtk_hbox_new (FALSE, 5);
	
	// Create the playlist treeview and list.
	scroll_pl = gtk_scrolled_window_new (NULL, NULL);
	gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (scroll_pl),
					GTK_POLICY_NEVER,
					GTK_POLICY_AUTOMATIC);

	pl_entries = gtk_list_store_new (NUM_COLS,
					 GDK_TYPE_PIXBUF,
					 G_TYPE_STRING,
					 G_TYPE_STRING,
					 G_TYPE_STRING,
					 G_TYPE_STRING);

	playlist = create_treeview (pl_entries);
	gtk_tree_view_set_rules_hint (GTK_TREE_VIEW (playlist), TRUE);
	gtk_container_add (GTK_CONTAINER (scroll_pl), playlist);
	selection = gtk_tree_view_get_selection (GTK_TREE_VIEW (playlist));
	gtk_tree_selection_set_mode (selection, GTK_SELECTION_BROWSE);

	playing_icon = gdk_pixbuf_new_from_inline (-1, playing_img, FALSE, NULL);
	paused_icon = gdk_pixbuf_new_from_inline (-1, paused_img, FALSE, NULL);
	volume_icon = gtk_image_new_from_pixbuf(gdk_pixbuf_new_from_inline (-1, volume_img, FALSE, NULL));

	/*playing_icon = gdk_pixbuf_new_from_file
				("./img/playing.png", NULL);
	paused_icon = gdk_pixbuf_new_from_file
				("./img/paused.png", NULL);
	volume_icon = gtk_image_new_from_file
				("./img/volume.png");*/

	// Create the buttons on the player.
	back = gtk_button_new ();
	//back_icon = gtk_image_new_from_file ("./img/back.png");
	back_icon = gtk_image_new_from_pixbuf(gdk_pixbuf_new_from_inline (-1, back_img, FALSE, NULL));
	gtk_button_set_image (GTK_BUTTON (back), back_icon);
	gtk_widget_set_tooltip_text (back, "Previous Track");
	
	play = gtk_button_new ();
	//play_icon = gtk_image_new_from_file ("./img/play.png");
	play_icon = gtk_image_new_from_pixbuf(gdk_pixbuf_new_from_inline (-1, play_img, FALSE, NULL));
	gtk_button_set_image (GTK_BUTTON (play), play_icon);
	gtk_widget_set_tooltip_text (play, "Play");

	pause = gtk_button_new ();
	//pause_icon = gtk_image_new_from_file ("./img/pause.png");
	pause_icon = gtk_image_new_from_pixbuf(gdk_pixbuf_new_from_inline (-1, pause_img, FALSE, NULL));
	gtk_button_set_image (GTK_BUTTON (pause), pause_icon);
	gtk_widget_set_tooltip_text (pause, "Pause");

	stop = gtk_button_new ();
	//stop_icon = gtk_image_new_from_file ("./img/stop.png");
	stop_icon = gtk_image_new_from_pixbuf(gdk_pixbuf_new_from_inline (-1, stop_img, FALSE, NULL));
	gtk_button_set_image (GTK_BUTTON (stop), stop_icon);
	gtk_widget_set_tooltip_text (stop, "Stop");

	next = gtk_button_new ();
	//next_icon = gtk_image_new_from_file ("./img/next.png");
	next_icon = gtk_image_new_from_pixbuf(gdk_pixbuf_new_from_inline (-1, next_img, FALSE, NULL));
	gtk_button_set_image (GTK_BUTTON (next), next_icon);
	gtk_widget_set_tooltip_text (next, "Next Track");

	add = gtk_button_new ();
	//add_icon = gtk_image_new_from_file ("./img/add.png");
	add_icon = gtk_image_new_from_pixbuf(gdk_pixbuf_new_from_inline (-1, add_img, FALSE, NULL));
	gtk_button_set_image (GTK_BUTTON (add), add_icon);
	gtk_widget_set_tooltip_text (add, "Add to Playlist...");

	remove = gtk_button_new ();
	//remove_icon = gtk_image_new_from_file ("./img/remove.png");
	remove_icon = gtk_image_new_from_pixbuf(gdk_pixbuf_new_from_inline (-1, remove_img, FALSE, NULL));
	gtk_button_set_image (GTK_BUTTON (remove), remove_icon);
	gtk_widget_set_tooltip_text (remove, "Remove from Playlist");

	open_pl = gtk_toggle_button_new ();
	//open_pl_icon = gtk_image_new_from_file ("./img/open_pl.png");
	open_pl_icon = gtk_image_new_from_pixbuf(gdk_pixbuf_new_from_inline (-1, open_pl_img, FALSE, NULL));
	gtk_button_set_image (GTK_BUTTON (open_pl), open_pl_icon);
	gtk_widget_set_tooltip_text (open_pl, "Open Playlist...");

	new_pl = gtk_button_new ();
	//new_pl_icon = gtk_image_new_from_file ("./img/new_pl.png");
	new_pl_icon = gtk_image_new_from_pixbuf(gdk_pixbuf_new_from_inline (-1, new_pl_img, FALSE, NULL));
	gtk_button_set_image (GTK_BUTTON (new_pl), new_pl_icon);
	gtk_widget_set_tooltip_text (new_pl, "New Playlist");

	help = gtk_button_new ();
	//help_icon = gtk_image_new_from_file ("./img/help.png");
	help_icon = gtk_image_new_from_pixbuf(gdk_pixbuf_new_from_inline (-1, help_img, FALSE, NULL));
	gtk_button_set_image (GTK_BUTTON (help), help_icon);
	gtk_widget_set_tooltip_text (new_pl, "About");

	#ifdef unix
	load_pl = gtk_button_new ();
	//load_pl_icon = gtk_image_new_from_file ("./img/load_pl.png");
	load_pl_icon = gtk_image_new_from_pixbuf(gdk_pixbuf_new_from_inline (-1, load_pl_img, FALSE, NULL));
	gtk_button_set_image (GTK_BUTTON (load_pl), load_pl_icon);
	gtk_widget_set_tooltip_text (load_pl, "Load Playlist...");

	save_pl = gtk_button_new ();
	//save_pl_icon = gtk_image_new_from_file ("./img/save_pl.png");
	save_pl_icon = gtk_image_new_from_pixbuf(gdk_pixbuf_new_from_inline (-1, save_pl_img, FALSE, NULL));
	gtk_button_set_image (GTK_BUTTON (save_pl), save_pl_icon);
	gtk_widget_set_tooltip_text (save_pl, "Save Playlist...");
	#endif

	separate = gtk_vseparator_new ();

	loop = gtk_toggle_button_new ();
	//loop_icon = gtk_image_new_from_file ("./img/loop.png");
	loop_icon = gtk_image_new_from_pixbuf(gdk_pixbuf_new_from_inline (-1, loop_img, FALSE, NULL));
	gtk_button_set_image (GTK_BUTTON (loop), loop_icon);
	gtk_widget_set_tooltip_text (loop, "Toggle Loop");

	shuffle = gtk_toggle_button_new ();
	//shuffle_icon = gtk_image_new_from_file ("./img/shuffle.png");
	shuffle_icon = gtk_image_new_from_pixbuf(gdk_pixbuf_new_from_inline (-1, shuffle_img, FALSE, NULL));
	gtk_button_set_image (GTK_BUTTON (shuffle), shuffle_icon);
	gtk_widget_set_tooltip_text (shuffle, "Toggle Shuffle");

	// Create scales.
	seek_adjust = gtk_adjustment_new (INITIAL_VALUE,
					  MIN_VALUE, MAX_VALUE,
					  1, 5, 5);
	vol_adjust = gtk_adjustment_new (INITIAL_VALUE,
					 MIN_VALUE, 1,
					 .05, .05, .05);
	
	seek_bar = gtk_hscale_new (GTK_ADJUSTMENT (seek_adjust));
	gtk_scale_set_draw_value (GTK_SCALE (seek_bar), FALSE);
	gtk_range_set_update_policy (GTK_RANGE (seek_bar),
				     GTK_UPDATE_CONTINUOUS);

	volume_bar = gtk_hscale_new (GTK_ADJUSTMENT (vol_adjust));
	gtk_scale_set_draw_value (GTK_SCALE (volume_bar), FALSE);
	gtk_range_set_update_policy (GTK_RANGE (volume_bar),
				     GTK_UPDATE_CONTINUOUS);
	gtk_widget_set_size_request (volume_bar, 80, -1);

	// Pack widgets into their containers.
	gtk_container_add (GTK_CONTAINER (window), vbox);

	#ifdef GDK_WINDOWING_X11
	gtk_box_pack_start (GTK_BOX (vbox), video, TRUE, TRUE, 0);
	#endif

	gtk_box_pack_start (GTK_BOX (vbox), track_label, FALSE, FALSE, 2);
	gtk_box_pack_start (GTK_BOX (vbox), hbox_seek, FALSE, FALSE, 2);
	gtk_box_pack_start (GTK_BOX (hbox_seek), seek_bar, TRUE, TRUE, 2);
	gtk_box_pack_start (GTK_BOX (hbox_seek), seek_label, FALSE, FALSE, 2);
	gtk_box_pack_start (GTK_BOX (vbox), hbox_buttons, FALSE, FALSE, 2);
	gtk_box_pack_start (GTK_BOX (hbox_buttons), back, FALSE, FALSE, 2);
	gtk_box_pack_start (GTK_BOX (hbox_buttons), play, FALSE, FALSE, 2);
	gtk_box_pack_start (GTK_BOX (hbox_buttons), pause, FALSE, FALSE, 2);
	gtk_box_pack_start (GTK_BOX (hbox_buttons), stop, FALSE, FALSE, 2);
	gtk_box_pack_start (GTK_BOX (hbox_buttons), next, FALSE, FALSE, 2);
	gtk_box_pack_start (GTK_BOX (hbox_buttons), open_pl, FALSE, FALSE, 15);
	gtk_box_pack_start (GTK_BOX (hbox_buttons),
			    volume_icon,
			    FALSE,
			    FALSE,
			    2);
	gtk_box_pack_start (GTK_BOX (hbox_buttons),
			    volume_bar,
			    FALSE,
			    FALSE,
			    2);
	gtk_box_pack_start (GTK_BOX (hbox_buttons), help, FALSE, FALSE, 2);

	gtk_container_add (GTK_CONTAINER (pl_window), vbox_pl);
	gtk_box_pack_start (GTK_BOX (vbox_pl), scroll_pl, TRUE, TRUE, 2);
	gtk_box_pack_start (GTK_BOX (vbox_pl), hbox_pl, FALSE, FALSE, 2);
	gtk_box_pack_start (GTK_BOX (hbox_pl), new_pl, FALSE, FALSE, 2);
	gtk_box_pack_start (GTK_BOX (hbox_pl), add, FALSE, FALSE, 2);
	gtk_box_pack_start (GTK_BOX (hbox_pl), remove, FALSE, FALSE, 2);
	#ifdef unix
	gtk_box_pack_start (GTK_BOX (hbox_pl), load_pl, FALSE, FALSE, 2);
	gtk_box_pack_start (GTK_BOX (hbox_pl), save_pl, FALSE, FALSE, 2);
	#endif
	gtk_box_pack_start (GTK_BOX (hbox_pl), separate, FALSE, FALSE, 10);
	gtk_box_pack_start (GTK_BOX (hbox_pl), loop, FALSE, FALSE, 2);
	gtk_box_pack_start (GTK_BOX (hbox_pl), shuffle, FALSE, FALSE, 2);

	// Set up the playbin, the comment lines at the end of lines are used
	// for debugging error purposes.
	bin = gst_element_factory_make ("playbin", "bin");
	bus = gst_pipeline_get_bus (GST_PIPELINE (bin));
	video_sink = gst_element_factory_make ("ximagesink", "video_sink"); //
	g_object_set (G_OBJECT (video_sink), "force-aspect-ratio", TRUE, NULL);

	g_object_set (G_OBJECT (bin), "video-sink", video_sink, NULL); //

	g_object_set_data (G_OBJECT (bus), "stop", stop);
	g_object_set_data (G_OBJECT (bus), "playlist", playlist);
	g_object_set_data (G_OBJECT (bus), "pl_entries", pl_entries);
	g_object_set_data (G_OBJECT (bus), "window", window);
	g_object_set_data (G_OBJECT (bus), "video_sink", video_sink); //
	gst_bus_add_watch (bus, bus_message, bin);

	g_object_set_data (G_OBJECT (bin), "seek_label", seek_label);
	g_object_set_data (G_OBJECT (bin), "seek_bar", seek_bar);
	timeout_id = g_timeout_add (100,
			           (GSourceFunc) track_bar_callback,
		  	            GST_PIPELINE (bin));
	gst_object_unref (bus);

	// Set the volume slider to the value of volume.
	g_object_get (G_OBJECT (bin), "volume", &volume, NULL);
	gtk_range_set_value (GTK_RANGE (volume_bar), volume);

	// Connect signals to their callback functions.
	g_object_set_data (G_OBJECT (window), "stop", stop);
	g_signal_connect (G_OBJECT (window), "destroy",
			  G_CALLBACK (quit_program), NULL);

	g_object_set_data (G_OBJECT (pl_window), "open_pl", open_pl);
	g_signal_connect (G_OBJECT (pl_window), "delete-event",
			  G_CALLBACK (pl_delete), NULL);

	g_object_set_data (G_OBJECT (back), "bin", bin);
	g_object_set_data (G_OBJECT (back), "play", play);
	g_object_set_data (G_OBJECT (back), "playlist", playlist);
	g_object_set_data (G_OBJECT (back), "pl_entries", pl_entries);
	g_signal_connect (G_OBJECT (back), "clicked",
			  G_CALLBACK (back_button_clicked), NULL);

	g_object_set_data (G_OBJECT (play), "track_label", track_label);
	g_object_set_data (G_OBJECT (play), "playing_icon", playing_icon);
	g_object_set_data (G_OBJECT (play), "playlist", playlist);
	g_object_set_data (G_OBJECT (play), "pl_entries", pl_entries);
	g_object_set_data (G_OBJECT (play), "bin", bin);
	g_object_set_data (G_OBJECT (play), "window", window);
	g_signal_connect (G_OBJECT (play), "clicked",
			  G_CALLBACK (play_button_clicked), window);

	g_object_set_data (G_OBJECT (pause), "pl_entries", pl_entries);
	g_object_set_data (G_OBJECT (pause), "playing_icon", playing_icon);
	g_object_set_data (G_OBJECT (pause), "paused_icon", paused_icon);
	g_object_set_data (G_OBJECT (pause), "bin", bin);
	g_signal_connect (G_OBJECT (pause), "clicked",
			  G_CALLBACK (pause_button_clicked), NULL);

	g_object_set_data (G_OBJECT (stop), "track_label", track_label);
	g_object_set_data (G_OBJECT (stop), "playlist", playlist);
	g_object_set_data (G_OBJECT (stop), "pl_entries", pl_entries);
	g_object_set_data (G_OBJECT (stop), "seek_bar", seek_bar);
	g_object_set_data (G_OBJECT (stop), "seek_label", seek_label);
	g_object_set_data (G_OBJECT (stop), "bin", bin);
	g_object_set_data (G_OBJECT (stop), "window", window);
	g_signal_connect (G_OBJECT (stop), "clicked",
			  G_CALLBACK (stop_button_clicked), NULL);

	g_object_set_data (G_OBJECT (next), "bin", bin);
	g_object_set_data (G_OBJECT (next), "play", play);
	g_object_set_data (G_OBJECT (next), "playlist", playlist);
	g_object_set_data (G_OBJECT (next), "pl_entries", pl_entries);
	g_signal_connect (G_OBJECT (next), "clicked",
			  G_CALLBACK (next_button_clicked), NULL);

	g_object_set_data (G_OBJECT (add), "pl_entries", pl_entries);
	g_object_set_data (G_OBJECT (add), "window", window);
	g_signal_connect (G_OBJECT (add), "clicked",
			  G_CALLBACK (add_button_clicked), NULL);

	g_object_set_data (G_OBJECT (remove), "playlist", playlist);
	g_object_set_data (G_OBJECT (remove), "pl_entries", pl_entries);
	g_signal_connect (G_OBJECT (remove), "clicked",
			  G_CALLBACK (remove_button_clicked), NULL);

        g_object_set_data (G_OBJECT (help), "window", window);
	g_signal_connect (G_OBJECT (help), "clicked",
			  G_CALLBACK (help_button_clicked), NULL);

	g_object_set_data (G_OBJECT (open_pl), "pl_window", pl_window);
	g_signal_connect (G_OBJECT (open_pl), "toggled",
			  G_CALLBACK (open_pl_button_clicked), NULL);

	g_signal_connect (G_OBJECT (loop), "toggled",
			  G_CALLBACK (loop_button_clicked), NULL);
	g_signal_connect (G_OBJECT (shuffle), "toggled",
			  G_CALLBACK (shuffle_button_clicked), NULL);

	g_object_set_data (G_OBJECT (new_pl), "pl_entries", pl_entries);
	g_signal_connect (G_OBJECT (new_pl), "clicked",
			  G_CALLBACK (new_pl_button_clicked), NULL);

	#ifdef unix
	g_object_set_data (G_OBJECT (load_pl), "pl_window", pl_window);
	g_object_set_data (G_OBJECT (load_pl), "pl_entries", pl_entries);
	g_signal_connect (G_OBJECT (load_pl), "clicked",
			  G_CALLBACK (load_pl_button_clicked), NULL);

	g_object_set_data (G_OBJECT (save_pl), "pl_window", pl_window);
	g_object_set_data (G_OBJECT (save_pl), "pl_entries", pl_entries);
	g_object_set_data (G_OBJECT (save_pl), "playlist", playlist);
	g_signal_connect (G_OBJECT (save_pl), "clicked",
			  G_CALLBACK (save_pl_button_clicked), NULL);
	#endif

	g_object_set_data (G_OBJECT (playlist), "track_label", track_label);
	g_object_set_data (G_OBJECT (playlist), "play", play);
	g_object_set_data (G_OBJECT (playlist), "remove", remove);
	g_object_set_data (G_OBJECT (playlist), "pl_window", pl_window);
	g_object_set_data (G_OBJECT (playlist), "playing_icon", playing_icon);
	g_object_set_data (G_OBJECT (playlist), "pl_entries", pl_entries);
	g_object_set_data (G_OBJECT (playlist), "bin", bin);
	g_object_set_data (G_OBJECT (playlist), "window", window);
	g_signal_connect (playlist,
			  "row-activated",
			  G_CALLBACK (double_click_row),
			  NULL);
	g_signal_connect (playlist,
			  "cursor-changed",
			  G_CALLBACK (focus_change),
			  NULL);

	g_object_set_data (G_OBJECT (volume_bar), "bin", bin);
	g_signal_connect (G_OBJECT (volume_bar),
			  "value-changed",
			  G_CALLBACK (volume_changed),
			  NULL);

	g_object_set_data (G_OBJECT (seek_bar), "bin", bin);
	g_object_set_data (G_OBJECT (seek_bar), "window", window);
	g_signal_connect (G_OBJECT (seek_bar),
			  "value_changed",
			  G_CALLBACK (seek_changed),
			  NULL);

	g_signal_connect (playlist,
			  "button-press-event",
			  G_CALLBACK (on_button_press),
			  NULL);
	g_signal_connect (playlist,
			  "popup-menu",
			  G_CALLBACK (playlist_popup),
			  NULL);

	// Show the window and all of its children.
	gtk_widget_show_all (window);

	// Code specific to environments using the X Window System.
	#ifdef GDK_WINDOWING_X11
	// Connect window state event to check for fullscreen.
	g_object_set_data (G_OBJECT (video), "window", window);
	g_object_set_data (G_OBJECT (video), "hbox_seek", hbox_seek);
	g_object_set_data (G_OBJECT (video), "hbox_buttons",
			   hbox_buttons);
	g_object_set_data (G_OBJECT (video), "track_label",
			   track_label);
	g_signal_connect (window, "window-state-event",
			  G_CALLBACK (window_fullscreen), NULL); 

	g_object_set_data (G_OBJECT (window), "open_pl", open_pl);
	g_object_set_data (G_OBJECT (window), "pause", pause);
	g_object_set_data (G_OBJECT (window), "hbox_seek", hbox_seek);
	g_object_set_data (G_OBJECT (window), "hbox_buttons",
			   hbox_buttons);
	g_object_set_data (G_OBJECT (window), "track_label",
			   track_label);
	g_signal_connect (window, "key-press-event",
			  G_CALLBACK (catch_window_key), NULL);
	g_signal_connect (window, "motion-notify-event",
			  G_CALLBACK (window_motion), NULL);

	// Realize the window to get the window XID.
	gtk_widget_realize (video);
	//printf("video_window_xid = %i\n", video_window_xid);
	g_assert (video_window_xid != 0);

	// Since XID needs to be set immediately, the sync handler
	// needs to be called once it's received.
	bus = gst_pipeline_get_bus (GST_PIPELINE (bin));
	gst_bus_set_sync_handler (bus, (GstBusSyncHandler) bus_sync,
				  NULL);
	gst_object_unref (bus);
	#endif

	// Start the main GTK loop.
	gtk_main();

	// Clean up.
	gst_element_set_state (bin, GST_STATE_NULL);
	gst_object_unref (GST_OBJECT (bin));
	gtk_tree_path_free (playing);

	return 0;
}
